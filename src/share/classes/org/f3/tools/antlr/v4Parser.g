/*
 * Copyright 2007-2009 Sun Microsystems, Inc.  All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * CA 95054 USA or visit www.sun.com if you need additional information or
 * have any questions.
 */

/////////////////////////////////////////////////////////////////////////////////
// Version 4+ of the F3 parser grammar.
//
// @author Stephen Chin
//
// Version 4 of the grammar reverts to a separate lexer and parser grammar without a separate
// ANTLR based AST walker. This is because this is the easiest way (at the time of writing)
// to confine error recovery to the smallest possible set of side effects on the resulting
// F3Tree. This is important for down stream tools such as code completion, which require
// as much of the AST as is possible to produce if they are to be effective.
//
// Derived from prior versions by:
//
// @author Jim Idle - Temporal Wave LLC
// @author Robert Field
// @author Zhiqun Chen
//
parser grammar v4Parser;

options { 

    // Rather than embed parser oriented Java code in this grammar, just to override
    // methods in the ANTLR base recognizer and derviative classes, we
    // instruct ANTLR to generate a class which is dervied from our own
    // super class. The super class is where we embody any code that does
    // not require direct access to the methods generated 
    // to implement the parser. Hence for instance this is where the 
    // F3TreeMaker lives.
    //
    superClass  = AbstractGeneratedParserV4; 

    // Import the token vocabulary, generated by the
    // lexer grammar analysis.
    //
    tokenVocab  = v4Lexer;
}

tokens
{
    LAST_TOKEN;
}

// This scope is used by rules that wish to change the
// location in which the error processing routines store the
// Erroneous nodes they create.
//
// As the parser descends the ruleset it needs to know where in the AST it
// should accumulate Erroneous nodes that represent parsing errors. Parsing
// errors do not always cause the rule that they occur in to receive an
// exception and therfore create an Erroneous node instead of whatever
// they would normally create. But we need to create an Erroneous node so
// that the error sink recives both start and end positions and so that the
// IDE can locate the error in the AST. The issue is where in the AST the
// error should be accumulated. If we are in the middle of a class definition
// then the error should be there, in a function definition, then part of the function
// definition and so on. 
//
// Each rule that need to change the error accumulation location creates
// a scope entry in this global scope and sets the ASTErrors member to be
// a reference to the list of things it is producing. The error routines then
// just append Erroneous nodes to the ListBuffer that is within the top
// entry of the stack.
//
scope errorStack {

    // Where the error routines should append any Erroneous nodes that
    // they create. We cannot use generics here as we are not always
    // accumulating F3Tree.
    //
    ListBuffer   ASTErrors;
    
}
// -----------------------------------------------------------------
// This section provides package and other information
// to the parser. It is inserted at the start of the generated parser
// code
//
@parser::header {

// Package specification for the generated parser class
//
package org.f3.tools.antlr;

// Parser specific inports.
//

import java.util.HashMap;
import java.util.Map;
import java.io.OutputStreamWriter;

import com.sun.tools.mjavac.tree.*;
import org.f3.tools.tree.*;
import org.f3.api.tree.*;

import com.sun.tools.mjavac.util.*;
import org.f3.tools.util.MsgSym;

import com.sun.tools.mjavac.code.*;
import org.f3.tools.code.F3Flags;
import static com.sun.tools.mjavac.util.ListBuffer.lb;
import org.f3.api.F3BindStatus;

import static org.f3.api.F3BindStatus.*;

}
 
@parser::members {

    /** Report a recognition problem.
     *
     *  This method sets errorRecovery to indicate the parser is recovering
     *  not parsing.  Once in recovery mode, no errors are generated.
     *  To get out of recovery mode, the parser must successfully match
     *  a token (after a resync).  So it will go:
     *
     *      1. error occurs
     *      2. enter recovery mode, report error
     *      3. consume until token found in resynch set
     *      4. try to resume parsing
     *      5. next match() will reset errorRecovery mode
     *
     * Note that because we must access the global scope stack, we cannot
     * place this method in the super class.
     */
    @Override
    public void reportError(RecognitionException e) {

        // If we've already reported an error and have not matched a token
        // yet successfully, don't report any errors.
        //
        if ( state.errorRecovery ) {

            // Don't count spurious
            //
            return;
        }
        state.syntaxErrors++;
        state.errorRecovery = true;

        displayRecognitionError(this.getTokenNames(), e);
        
        // The displayRecognitionError() method creates an Erroneous
        // node that spans the error. As we were nto given a specific
        // AST node by which to report the error to the diagnostic listener
        // then we append this error node to the list of elements the
        // parser is accumulating, whcih is always the ListBuffer at the
        // top of the global scope 'errorStack'
        //
        errorStack_scope es = ((errorStack_scope)errorStack_stack.peek());
        es.ASTErrors.append(errorNode);
        
    }

   /**
     * Acts as per the standard error reporting, but instead of allowing the
     * normal displayRecognition error to report with reference to the tokens
     * it has consumed, we always report with reference to the supplied node.
     *
     * Because the standard reportError() method must reside in the generated
     * class so it has access to the scope class, we keep this version of the 
     * method here too, for consistency.
     
     * @param e The recognition exception to report on
     * @param node The node we wnat to report with reference to.
     */
    public void reportError(RecognitionException e, F3Tree node) {

        // if we've already reported an error and have not matched a token
        // yet successfully, don't report any errors.
        //
        if ( state.errorRecovery ) {

            // Don't count spurious
            //
            return;
        }

        state.syntaxErrors++;
        state.errorRecovery = true;

        displayRecognitionError(this.getTokenNames(), e, node);

    }   
}
// ------------------------------------------------------------------       
// ------------------------------------------------------------------
// PARSER RULES
//
// The parser consumes the token stream created by calling the lexer until
// we see EOF. When the parser starts, the entire token stream is created.
// We cannot do syntax directed parsing as it means you cannot use LL(*)
// algorithms for grammar analysis and code generation.
//
// The parsers job is to produce the F3 specialized AST, which
// is the basis for all the rest of the tool chain, including symbol table and code 
// generation as well as code completion for editors and so on.
// ------------------------------------------------------------------

/**
 * The usual entry point for the F3 parser, this will parse a complete
 * script body and manufacture the F3 AST.
 *
 * A script, like many other syntactical elements, can have an associated
 * comment. When the parse is complete, we scan the tokens that are normally
 * hidden from the parser looking for comments and associate them with
 * AST node for the script.
 */
script

    returns [F3Script result]
    
// Where the error routines should accumulate erroneous nodes. There
// should not really be any accumulated here, but perhaps the packageDecl
// routine may throw something out.
//  
scope errorStack;

@init
{
    // Search for the document comment token. At this point LT(1)
    // returns the first on channel token, so we can scan back from
    // there to see if there was a document comment.
    //
    CommonToken  docComment = getDocComment(input.LT(1));

    // AST start position
    //
    int rPos = pos();
    
    // Initialize the tree map if we are creating the AST end position
    // map.
    //
    endPositions = genEndPos ? new HashMap<JCTree,Integer>() : null;
    
    // Initialize document comment collection
    //
    docComments = null;
    
    // Initialize the error accumulator
    //
    $errorStack::ASTErrors = new ListBuffer<F3Tree>();
}

    :  pd=packageDecl si=scriptItems 
    
        {
            // If the parser threw out any error messages, we want to
            // enter them in to the AST for later analysis if required, but mainly
            // so they are available to the log sync. The only errors accumulated here
            // have to be before the script items, so they are prepended to the
            // item list, rather than appended
            //
            for (Object e : $errorStack::ASTErrors) {
                $si.items.prepend((F3Tree)e);
            }
            
            // Construct the F3 AST
            //
            $result = F.Script($packageDecl.value, $si.items.toList());
            setDocComment($result, docComment); // Add any detected documentation comment
            
            // Set tree span and endpoint map (if required).
            //
            $result.pos = rPos;
            endPos($result); 
            
            // Pass on the documentation comments and the endpos map
            //
            $result.docComments     = docComments;
            $result.endPositions    = endPositions;

        }

        EOF     // Forces parser to consume entire token stream or error out
    ;
    
// ----------------------    
// Package specification.
// The package declaration is optional. It qualifes the namespace/location
// of all subsequent delcarations in the script.
//
packageDecl

    returns [F3Expression value]   // Package declaration builds a F3Expression tree

@init
{
    // AST start position
    //
    int rPos = pos();
}
    : PACKAGE qualname possiblyOptSemi
    
            { 
                $value = $qualname.value;
            }
            
    | // No package specified
    
            { $value = null; }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);

    // Error node for AST
    //
    $value = F.at(rPos).Erroneous();
    endPos($value);
 }
 
// ----------------
// Script elements.
// Zero or more script elements belong to a script. Script elements
// are allowed to be completely empty, or effectively empty by
// existing as a SEMI (semi colon only). This structure allows
// class definitions and function definitions to appear to be
// only optionally terminated with a SEMI. The language spec allows
// ONLY class definitions and function definitions to be optionally
// terminated in this way, other constructs MUST be terminated
// with a SEMI.
//
scriptItems

    
    returns [ListBuffer<F3Tree> items = new ListBuffer<F3Tree>()] // This rule builds a list of F3Tree, which is used 
                                                                    // by the caller to build the actual AST.
                                                                    //
                                                                    
// Where the error routines should accumulate erroneous nodes. Any errors 
// here are at the script level of course.
//  
scope errorStack;

@init
{
    // AST start position
    //
    int rPos = pos();
    
    // Where to append any Erroneous nodes
    //
    $errorStack::ASTErrors = $items;
    
}
    :   (scriptItem[$items] possiblyOptSemi)*
    ;

// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);

    // Error node for AST
    //
    F3Erroneous value = F.at(rPos).Erroneous();
    endPos(value);
    $items.append(value);
    
 }
 
scriptItem  [ListBuffer<F3Tree> items] // This rule builds a list of F3Tree, which is used 
                                        // by the caller to build the actual AST.
                                        //
@init
{
    // Record the start position of this rule, in case of errors
    //
    int rPos = pos();
    
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    
}
    :
              // Certain script members may be prefixed with modifiers
              // such as 'public'. We allow the parser to first consume 
              // all modifier keywords, regardless of whether this is a 
              // valid modifier for the upcoming declaration. Whether it is
              // valid or not is a matter for semantic checks to decide.
              //
              //
	(modifiers (ENUM|CLASS|INTERFACE|FUNCTION))=> (m1=modifiers { errNodes.append($m1.mods); }
                (
                      c=classDefinition         [$m1.mods, $m1.pos]
                      
                            {   errNodes.append($c.value);
                                $items.append($c.value); 
                            }
                    | enumDefinition [$m1.mods, $m1.pos] {}
                    | f=functionDefinition      [$m1.mods, $m1.pos]
                    

                            { 
                                errNodes.append($f.value);
                                $items.append($f.value); 
                            }
		 ))
            
            |  typeAlias { $items.append($typeAlias.rtype); }
                
            | i=importDecl
            
                { 
                    errNodes.append($i.value);
                    $items.append($i.value); 
                }
            
            | s=statement
            
                { 
                    errNodes.append($s.value);
                    $items.append($s.value); 
                }
            
            | SEMI
    ;

// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input. If we receive an exception here
// it is because whatever token was next in the input stream did not predict
// any of the alts. So, we recover the input stream up to the next token
// in the followset (standard ANTLR recovery), then build an erroneous node
// that contains no sub trees, but identifies the start and end of the
// error
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);

    // Now construct an Erroneous node to span the error nodes
    // 
    F3Erroneous errors = F.at(rPos).Erroneous(errNodes.elems);
    endPos(errors);
    
    // And add this in to the script item list
    //
    $items.append(errors);
 }
 
// -----------------    
// Import statement.
// Include definitions from an external source
//
importDecl

    returns [F3Tree value] // The import declaration is built as a generic F3Tree

@init
{
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    
    // Record the start position of this rule, in case of errors
    //
    int rPos = pos();
    

}
    
    : IMPORT importId
    
        {
            // AST construction
            $value = F.at(rPos).Import($importId.pid);
            
            // AST span
            //
            endPos($value);
        }
    ;
    
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Error node for AST, note that if we found an importId then we would
    // not be in the exception handler, so no need to accumulate it for
    // error.
    //
    $value = F.at(rPos).Erroneous();
    endPos($value);

 }
 
// ------------
// Import spec.
// Parses the (possibly) qualifed name space that the script must import,
//
importId

    returns [F3Expression pid] // Qualified names are built as expression trees

@init
{
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    
    // Record the start position of this rule, in case of errors
    //
    int rPos = pos();
    
    // Flag indicates that the token sequence was in error
    //
    boolean inError = false;
    
    // Flag indicates that we have seen .'*' already
    //
    boolean haveStar = false;
    
    // Record the posiotn of any START we find, in case we want to error upon it
    //
    int starP = 0;
}
    : i1=identifierAll
        {
            $pid = $i1.value;
            
            // Accumulate in case of error, and flag if the indentifer was not there
            //
            errNodes.append($i1.value);
            inError = $i1.inError;
        }
        ( 
            (
                  DOT 
                | DOTDOT
                    {
                        // If the programmer accidentally typed import X..y; then the
                        // lexer will see that as a range operator, but here, that tells
                        // us there was a missing qualifer
                        //
                        inError = true;     // Signal that this is malformed
                        log.error(pos($DOTDOT)+1, MsgSym.MESSAGE_F3_INCOMPLETE_QUAL);
                    }
            )
                (
                    (nameAll)=> n2=nameAll
                    {
                        // Check for errors
                        //
                        if  ($n2.inError || $n2.value == null)
                        {
                            // We should not be able to get this, as the follow set
                            // will not allow error recovery to insert a token as
                            // it is not singular - which one should it insert? However
                            // future improvements may make this happen, so code for it anyway
                            //
                            log.error(semiPos(), MsgSym.MESSAGE_F3_INCOMPLETE_QUAL);
                        }
                        
                        $pid = F.at($n2.pos).Select($pid, $n2.value, false);
                        endPos($pid);
                    
                        // Build up new node in case of error
                        //
                        F3Expression part = F.at($n2.pos).Ident($n2.value);
                        errNodes.append(part);
                        endPos(part);

                        // If we already had a '.*' part, then this makes no sense
                        //
                        if  (haveStar) {
                        
                            inError = true;     // Signal that this is malformed
                            log.error(part, MsgSym.MESSAGE_F3_IMPORT_BAD_NAME);
                        }
                    }

                |   (STAR)=>s1=STAR (s2=STAR)?
            
                    {
                        // Whether '*' || '**'
                        //
                        Name starBit;
                        
                        if  ($s2 == null) {
                        
                            // Second star was not present
                            //
                            starBit = names.asterisk;
                            
  
                            
                        } else {
                        
                            // Second star WAS present
                            //
                            starBit = names.fromString("**");
                            
                            // Note that ** has been reverted from the runtime, so we just
                            // replace it with single star for the moment, and issue an error
                            // Delete this comment and the next two lines when the runtime supports 
                            // this again.
                            //
                            inError = true;     // Signal that this is malformed
                            starBit = names.asterisk;
                            F3Expression part = F.at(starP).Ident(starBit);
                            endPos(part);
                            log.error(part, MsgSym.MESSAGE_F3_IMPORT_BAD_STAR);
                            
                        }
                        
                        $pid = F.at($n2.pos).Select($pid, starBit, false);
                        endPos($pid);

                        // Build up new node in case of error
                        //
                        starP = pos($s1);
                        F3Expression part = F.at(starP).Ident(starBit);
                        errNodes.append(part);
                        endPos(part);
                        
                        // If we already had a '.*{*}' part, then this makes no sense
                        //
                        if  (haveStar) {
                        
                            inError = true;     // Signal that this is malformed
                            log.error(part, MsgSym.MESSAGE_F3_IMPORT_BAD_STAR);
                        }
                        
                        
                        // Signal that we have a star now
                        //
                        haveStar = true;
                    }
                    
                |   // Erroneous
                
                    {
                        // THis does not cause an errneous node, we just generate a missing
                        // qualifier.
                        //
                        Name missing = Name.fromString(names, "<missing>");
                        F3Expression part = F.at(semiPos()).Ident(missing);
                        errNodes.append(part);
                        endPos(part);
                        $pid = F.at(pos($DOT)).Select($pid, missing, false);
                        endPos($pid);
                        log.error(semiPos(), MsgSym.MESSAGE_F3_INCOMPLETE_QUAL);
                    }
                    
                )

        )*
        
        {
            // Was the seqeunce in error? Note that not all syntax errors
            // cause this. 
            //
            if  (inError) {
                $pid=F.at(rPos).Erroneous(errNodes.elems);
                endPos($pid);
            }
        }
    ;
    
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // And we need to return an erroneous node
    //
    $pid=F.at(rPos).Erroneous(errNodes.elems);
    endPos($pid);   
 }
 

// ----------
// Modifiers.
// Collects the modifier flags for all known modifiers, regardless
// of their validity with the declaration they will be associated with.
// Attributing will verify the semantics of the modifiers.
//
modifiers

    returns [F3Modifiers mods, int pos]    // Constructs and returns a specialized modifer node

@init {

    // The flags we build up for the AST
    //
    long    flags   = 0;
    
    // The start character position for this AST
    //
    $pos        = pos();
}

    :   (   
            mf=modifierFlag
            
            {
                // Or in the newly discovered modifier
                //
                flags   |= $mf.flag;
            }
    
        )*
        
        {
            // Build the modifier flags (just as empty if we did not pick any up)
            //
            $mods = F.at($pos).Modifiers(flags);

            // Tree span
            //
            endPos($mods);
        }
    ;

 
// ---------------
// Modifier flags.
// All the possible modifier keywords that can be applied to 
// constructs such as var, class and so on,
//
modifierFlag

    returns [long flag]
    
    : ABSTRACT          { $flag = Flags.ABSTRACT;           }
    | BOUND             { $flag = F3Flags.BOUND;            }
    | DEFAULT           { $flag = F3Flags.DEFAULT;          }
    | MIXIN             { $flag = F3Flags.MIXIN;            }
    | OVERRIDE          { $flag = F3Flags.OVERRIDE;         }
    | PACKAGE           { $flag = F3Flags.PACKAGE_ACCESS;   }
    | PROTECTED         { $flag = Flags.PROTECTED;          }
    | PUBLIC            { $flag = Flags.PUBLIC;             }
    | (PUBLIC (VAL|CONST)|PUBLIC_READ)       { $flag = F3Flags.PUBLIC_READ;      }
    | PUBLIC_INIT       { $flag = F3Flags.PUBLIC_INIT;      }
        
    
    //TODO: deprecated -- remove these at some point
    //                    For now, error about their deprecation
    //
    | PRIVATE           { 
                            F3Erroneous err = F.at(pos($PRIVATE)).Erroneous();
                            endPos(err);
                            log.error(err, MsgSym.MESSAGE_F3_NOT_SUPPORTED_PRIVATE); 
                        }
    | STATIC            { $flag = Flags.STATIC;                 }
    ;

// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
 }

enumDefinition [ F3Modifiers mods, int pos ]

    returns [F3Tree value] // The class definition has its own F3Tree type, but we might need Erroneous here
    
    // Shift contexts for error accumualtion
    //
    scope errorStack;
    
@init { 

    // Search for the document comment token. At this point LT(1)
    // returns the first on channel token, so we can scan back from
    // there to see if there was a document comment.
    //
    CommonToken  docComment         = getDocComment(input.LT(1));

    // List of all members
    //
    ListBuffer<F3Tree> mems        = new ListBuffer<F3Tree>();
    
    // Super class ids
    //
    ListBuffer<F3Expression> ids   = null;
    
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    $errorStack::ASTErrors          = mems;

    // Accumulate any generic arguments
    //
    ListBuffer<F3Expression> exprbuff = ListBuffer.<F3Expression>lb();
}

    : ENUM 


    n1=name 

    (OF gas=genericParams[false, false] {
            exprbuff.appendList(gas);
    })?
    LBRACE
    name (OF type)? ((COMMA|SEMI)+ name (OF TYPE)?)*
    RBRACE
    
;
 
// Class definition.
// Parses a complete class definition and builds up the F3 AST
// that represents this.
//
// param mods The previously built modifier flags
//
classDefinition [ F3Modifiers mods, int pos ]

    returns [F3Tree value] // The class definition has its own F3Tree type, but we might need Erroneous here
    
    // Shift contexts for error accumualtion
    //
    scope errorStack;
    
@init { 

    // Search for the document comment token. At this point LT(1)
    // returns the first on channel token, so we can scan back from
    // there to see if there was a document comment.
    //
    CommonToken  docComment         = getDocComment(input.LT(1));

    // List of all members
    //
    ListBuffer<F3Tree> mems        = new ListBuffer<F3Tree>();
    
    // Super class ids
    //
    ListBuffer<F3Expression> ids   = null;
    
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    $errorStack::ASTErrors          = mems;

    // Accumulate any generic arguments
    //
    ListBuffer<F3Expression> exprbuff = ListBuffer.<F3Expression>lb();
}

    : (INTERFACE {$mods.flags |= F3Flags.MIXIN;} | CLASS  )


            n1=name 

        (OF|FROM|TO)=>((OF gas=genericParams[false, false] {
           if (gas != null) exprbuff.appendList(gas);
        })?
        |
        (FROM contraGas=genericParams[true, false] {
            if (contraGas != null) exprbuff.appendList(contraGas);
        })?
        (TO coGas=genericParams[false, true] {
            if (coGas != null) exprbuff.appendList(coGas);
        })?    
        )
    
        (EXTENDS)=>(supers  {ids = $supers.ids; })
            
        LBRACE 
    
            // Consume any garbled declarations so that we don't drop out
            // of parsing the class until we hit '}' for the class definition
            // or get to something that is so garbled we have no choice.
            //
            syncClass       [mems] 
            
            ( 
                classMember         [mems] 
                
                possiblyOptSemi
                
                syncClass           [mems]
            )*
            
        RBRACE
        
        { 
            $value = F.at($pos).ClassDeclaration
                (
                              
                    $mods,  
                    $n1.value,
                    ids.toList(),
                    mems.toList()
                );
                ((F3ClassDeclaration)$value).typeArgs = exprbuff.toList();
                setDocComment($value, docComment);  // Add any detected documentation comment
                endPos($value, pos($RBRACE)); 
        }
    ;
    
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // However, we need to collect the nodes we found into an Erroneous class
    // definition, as if the got an error in this rule, it was a pretty high
    // up problem, syntactically. Something like "public class" and nothing else
    // which can of course come in from IDEs/Editors, all the time. Because the
    // parser is pretty good at recovering from nonsense in the declaration, we will
    // usually only get here for missing elements of the class definition. So, rather
    // than always throwing the entire class into an erroneous state, we see if we 
    // have enough to build a class definition that the IDE can use anyway. The 
    // litmus test for that is whether we gathered any member definitions at all.
    // If we did, then we will have a class name and 0 or more supers and so on
    // and so we can build the class definition. (Quite often we get here because of a lack
    // of a closing '}', so we don;t want to abandon the class just because of that.
    //

    // We always have enough to build a class definition AST for the IDE because we will
    // manufacture a name of <missing> if there wasn't one. That's all the class node
    // really needs.
    // 
    $value = F.at($pos).ClassDeclaration
                (             
                    $mods,  
                    $n1.value,
                    ids.toList(),
                    mems.toList()
                );
    System.err.println("exprbuff "+$n1.value+"="+exprbuff.toList());
    ((F3ClassDeclaration)$value).typeArgs = exprbuff.toList();
    setDocComment($value, docComment);  // Add any detected documentation comment
    
    // AST span
    //
    endPos($value);
    
 }
 
// -----------------
// Super class spec.
// Parses a list of super classes for a class definition and builds the
// associated F3 AST.
//
supers 

    returns [ListBuffer<F3Expression> ids = new ListBuffer<F3Expression>()]   // The return is a list of F3 expressions representing one
                                                                                // or more super class type name.
@init
{
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    
    // Start position in case of error
    //
    int rPos = pos();
}
    : EXTENDS t1=type
            {
                $ids.append($t1.rtype);
                errNodes.append($t1.rtype);
            }
           ( 
            COMMA t2=type
            
                { 
                    $ids.append($t2.rtype);
                    errNodes.append($t2.rtype);
                }
           )*
           
    | // Upsilon - this class inherits no other types so the list will be empty
    ;

// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Produce the ERRONEOUS node
    //
    $ids = new ListBuffer<F3Expression>();
    F3Erroneous errnode = F.at(rPos).Erroneous(errNodes.elems);
    endPos(errnode);
    $ids.append(errnode);
 }
    
 // ---------------------------- 
// Statement/Expression resync for class declaration.
// If left to itself, the class rule cannot easilly resync to the start of a statement
// because we will throw an exception on trying to work out if we can insert or
// delete a token.
//
// If we use this rule after the open '{' before the start of every complete/recoverable
// definition contained in a declarations block, then it will be called unconditionally (it always
// matches the next token because it is the upsilon set). Most importantly, the followset
// stack will contain the follow set that is allowed to start a new declaration. Hence our
// init rule just uses the trick of syncing to the next good declaration, and throwing out
// any garbled definitions with a neat error. We will always be positioned at a token that
// can start a new defintion, or the closing '}' or in rare cases, then the sync funciton 
// will have to give in because the code is just too garbled (but all bets are off at that
// point.)
// 
// We record the token stream start position on rule entry, and upon rule exit
// if we consumed any tokens, then we add an Erroneous node to the AST and everyone is
// happy.
//
syncClass[ListBuffer<F3Tree> mems]
@init
{
    // Start of rule for error node production
    //
    int rPos    = pos();
    
    // Consume any garbled tokens that come before the next statement
    // or the end of the block. The only slight risk here is that the
    // block becomes MORE inclusive than it should but as the script is
    // in error, this is a better course than throwing out the block
    // when the error occurs and screwing up the whole meaning of
    // the rest of the token stream.
    //
    syncToGoodClassToken();  // Temporary method call - found bug in ANTLR 3.1 followset computation!
}
@after
{
    // If we consume any tokens at this point then we create
    // an ERRONEOUS AST node for the IDE to monitor and add it
    // in to the staement list.
    //
    if  (rPos != pos()) {
    
        // Span all the tokesn we had to consume.
        //
        F3Erroneous errNode = F.at(rPos).Erroneous();
        endPos(errNode);
        $mems.append(errNode);
        
        // Tell the script author where we think there is a screwed up expression
        //
        log.error(errNode, MsgSym.MESSAGE_F3_GARBLED_DECLARATION);
    }
}
    :   // Deliberately match nothing, causing this rule always to be 
        // entered.
    ;


 
// --------------
// Class members.
// Parses all constructs that can be a member of a class and returns
// the F3 AST that represents it.
//
classMember[ListBuffer<F3Tree> mems]

    returns [F3Tree member]        // A class member has a specialized F3 tree node, which is what
                                    // we return from this rule.

 @init {

    // The start character position for this AST
    //
    int rPos        = pos();
    
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();

}

    : initDefinition                { $mems.append($initDefinition.value);      }
    | postInitDefinition            { $mems.append($postInitDefinition.value);  }
    |
        m=modifiers 
      
        (
           variableDeclaration      [$m.mods, $m.pos]       { $mems.append($variableDeclaration.value); }
         | functionDefinition       [$m.mods, $m.pos]       { $mems.append($functionDefinition.value);  }
    )
    | SEMI
    
    ;
    
// Catch an error when looking for a class member. We create an erroneous node
// for anything that was at the start up to wher
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform custom resyncing for class members
    //
    $mems.append(resyncClassMember(rPos, re));
    
 }

// ----------
// Functions.
// While functions can be declared at any level, their syntax is the same.
// As always, the semantic pass of the F3 tree must verify that the
// supplied modifers are valid in this context.
//
functionDefinition [ F3Modifiers mods, int pos ]

    returns [F3Tree value]     // A function defintion has a specialized node in the F3 AST

@init { 

    // Search for the document comment token. At this point LT(1)
    // returns the first on channel token, so we can scan back from
    // there to see if there was a document comment.
    //
    CommonToken  docComment = getDocComment(input.LT(1));

    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    
    // Function name we accumulate one way or another (manufacture if missing)
    //
    F3Ident id;
    
    // Start of rule for error node production/
    //
    int rPos    = pos();
    
    // Is this an override?
    //
    boolean isOverride = (F3Flags.OVERRIDE & $mods.flags) == F3Flags.OVERRIDE;
    
    // The Name symbol we create
    //
    Name name = null;

    F3Block blk = null;

    // Accumulate any generic arguments
    //
}
: FUNCTION  

   ((OF | FORALL) genericArgs = genericParams[false, false])?

        (
            (
                  { false }?=> n2=nameAll
                    {
                        if ($n2.inError || $n2.value == null) {
                        
                            // First, lets report the error as the user needs to know about it
                            // Issue an error - can't have anonymous functions
                            //
                            log.error(pos(), MsgSym.MESSAGE_F3_FUNC_UNNAMED);
                        }
                        // Accumulate a node in case of error
                        //          
                        id = F.at($n2.pos).Ident($n2.value);
                        name = $n2.value;
                        endPos(id);
                    
                        // Accumulate in case of error
                        //
                        errNodes.append(id);
                    }
                  
                | n1=name
                    {       
                        if ($n1.inError || $n1.value == null) {
                        
                            // First, lets report the error as the user needs to know about it
                            // Issue an error - can't have anonymous functions
                            //
                            log.error(pos(), MsgSym.MESSAGE_F3_FUNC_UNNAMED);
                        }
                        // Accumulate a node in case of error
                        //          
                        id = F.at($n1.pos).Ident($n1.value);
                        name = $n1.value;
                        endPos(id);
                    
                        // Accumulate in case of error
                        //
                        errNodes.append(id);
                    }
                
            )
                
        )
        formalParameters
            {
                // Accumulate the parameter nodes in case of error
                //
                for (F3Tree t : $formalParameters.params) {
                    errNodes.append(t);
                }
            }
            
        typeReference 
            {
                // Accumulate in case of error
                //
                errNodes.append($typeReference.rtype);
            }
    
        // The function block is optional if this is an abstract funtino definition
        // but in that case a semi colon is required. If this is not an abstract function
        // we let the attribution function report that there is no function body defined
        // as this may be coming from an IDE.
        //
        (     (LBRACE)=>block [-1]
        
                {
                    // Accumulate in case of error
                    //
                    errNodes.append($block.value);
                    blk = $block.value;
                }
            
            |   // This alt is selected only if the function declaration is not abstract
                // and there was no function body. If there is a SEMI at this point, it does not
                // matter as it will be eaten by the enclosing rule as if it were an empty statement.
                //
             RETURN? bodyExpr=expression { blk = F.at(pos($FUNCTION)).Block(0L, com.sun.tools.mjavac.util.List.<F3Expression>of(bodyExpr), null); }
            |
            SEMI

        )
    
        {
            // Create the function defintion AST
            //
            $value = F.at($pos).FunctionDefinition
                            (
                                $mods,
                                name, 
                                $typeReference.rtype,
                                $formalParameters.params.toList(), 
                                blk
                            );
	    if (genericArgs != null) {
		((F3FunctionDefinition)$value).typeArgs = genericArgs;
	    }
            // Ensure that the function value, manufactured within the FunctionDefinition() method
            // call, receives an endPos() map
            //
            endPos(((F3FunctionDefinition)($value)).operation);
            
            // Documentation comment (if any)
            //
            setDocComment($value, docComment);
            
            // Tree span
            //
            endPos($value); 
        }
    ;

// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Produce an error node rather than a function definition node.
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
 }
 
 
// ------------
// Init block.
// Parse the initialization block for a class definition.
// Note that we allow more than one of these syntactically.
//
initDefinition

    returns [F3Tree value] // The initialisation block has a specialized F3 tree node

@init
{
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    
    // Start of rule for error node production/
    //
    int rPos    = pos();
}
    : INIT block [ -1 ]
    
        {
            // Build the AST
            //
            $value = F.at(pos($INIT)).InitDefinition($block.value);
            
            // Tree span
            //
            endPos($value); 
        }
    ;

// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // If we took an exception, then there will not be a block to construct
    //
    $value = F.at(rPos).Erroneous();
 }
 
// Post initialization.
// Parse the post initialization block and produce the AST
//
postInitDefinition

    returns [F3Tree value] // Post initialization has its own specialized F3 tree node

@init
{
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    
    // Start of rule for error node production/
    //
    int rPos    = pos();
}

    : POSTINIT block [-1]
        { 
            // Build the AST
            //
            $value = F.at(pos($POSTINIT)).PostInitDefinition($block.value);

            // Tree span
            //
            endPos($value); 
        }
    ;
    
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // If we took an exception, then there will not be a block to construct
    //
    $value = F.at(rPos).Erroneous();
 }
 
//triggerDefinition
//  : WITH name onReplaceClause     -> ^(WITH name onReplaceClause)
//  ;


// Variables.
// While they can be defined at different levels (script, member, local) the syntax
// for declaring variables, and the modifiers and so on are all exactly
// the same (syntactically) at all levels.
// Parses a variable declaration and return the resultant F3 expression tree.
//
variableDeclaration [ F3Modifiers mods, int pos ]

    returns [F3Expression value]

@init { 

    // Search for the document comment token. At this point LT(1)
    // returns the first on channel token, so we can scan back from
    // there to see if there was a document comment.
    //
    CommonToken  docComment = getDocComment(input.LT(1));

    // Bind status if present
    //
    F3BindStatus bStatus = null;

    // Bind value expression, if present
    //
    F3Expression bValue = null;

    // does thie variable have an on-replace trigger?
    //
    boolean seenOnReplace = false;

    // does thie variable have an on-invalidate trigger?
    //
    boolean seenOnInvalidate = false;

    // ONReplace clause if present
    //
    F3OnReplace  onReplaceValue = null;

    // ONInvalidate clause if present
    //
    F3OnReplace  onInvalidateValue = null;
 
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
   
    // Used by error accumulation and override construction
    //
    F3Ident part = null;
   
}
    : variableLabel  
    
        n=name
        
            { 
                // Build up new node in case of error
                //
                part = F.at($n.pos).Ident($n.value);
                endPos(part, $n.pos);   // Was not really there
                errNodes.append(part);
            }
            
        tr=typeReference    { errNodes.append($tr.rtype); }  // Accumulate for errors
        
        (
              (EQ)=>EQ boundExpression
                {
                    bValue  = $boundExpression.value;
                    bStatus = $boundExpression.status;
                    errNodes.append($boundExpression.value);
                }
                
            | // Missing initializer. This is fine for var, but cannot be
              // the case for def, so we create an erroneous node for the intializer
              // in that case, and positoin it where the initializer should be.
              //
              {
                if  (($variableLabel.modifiers & F3Flags.IS_DEF) == F3Flags.IS_DEF) {
                
                    // Create an erroneous node where we should have the intializer
                    //
                    bStatus = UNBOUND;
                    bValue  = F.at(semiPos()).Erroneous();
                    endPos(bValue);                         // End pos will adjust span so that it is one character long.
                    
                    // Send out the error
                    //
                    log.error(bValue, MsgSym.MESSAGE_F3_BAD_DEF, $name.text);
                }
              
              }
        )

        
        (: (ON REPLACE)=>onReplaceClause
                {
                    onReplaceValue = $onReplaceClause.value;
                    if (seenOnReplace) {
                       log.error(onReplaceValue.pos(), MsgSym.MESSAGE_F3_DUPLICATE_TRIGGER_DEF);
                    }
                    else {
                        seenOnReplace = true;
                    }
                    errNodes.append($onReplaceClause.value);
                }
        |
        (INVERSE) => INVERSE fieldName=IDENTIFIER
        |
        (ON INVALIDATE)=>onInvalidateClause
                {
                    onInvalidateValue = $onInvalidateClause.value;
                    if (seenOnInvalidate) {
                       log.error(onInvalidateValue.pos(), MsgSym.MESSAGE_F3_DUPLICATE_TRIGGER_DEF);
                    }
                    else {
                        seenOnInvalidate = true;
                    }
                    errNodes.append($onInvalidateClause.value);
                }
        )*
    
        {
            // Add in the modifier flags accumulated by the label type
            // Note that syntactically, we allow all label types at all levels and must throw
            // out any invalid ones at the semantic checking phase
            //
            long vmod = $variableLabel.modifiers;
            if (vmod == F3Flags.PUBLIC_INIT) { 
                if (($mods.flags & Flags.PUBLIC) != 0) {
                    $mods.flags &= ~Flags.PUBLIC;
                } else {
                    //const
                    vmod = F3Flags.IS_DEF;
                }
            } else if (vmod == F3Flags.PUBLIC_READ) { 
                if (($mods.flags & Flags.PUBLIC) != 0) {
                    $mods.flags &= ~Flags.PUBLIC;
                } else {
                    //const 
                }
            }
            $mods.flags |= vmod;
            
            // Construct the variable F3Tree, unless it was in error
            //
            if  ($n.inError) {
            
                $value = F.at($pos).Erroneous(errNodes.elems);
                
            } else {
            
                // Here, we can have either an OVERRIDE or a straight
                // declaration, but the AST nodes are different.
                //
                if  (($mods.flags & F3Flags.OVERRIDE) == F3Flags.OVERRIDE) {
                
                    // Build the AST for OVERRIDE var
                    //
                    $value = F.at($pos).OverrideClassVar
                        (
                            $name.value,
                            $typeReference.rtype,
                            $mods,
                            part,
                            bValue,
                            bStatus,
                            onReplaceValue,
                            onInvalidateValue
                        );

                } else {
                
                    $value = F.at($pos).Var
                        (
                            $name.value,
                            $typeReference.rtype,
                            $mods,
                            bValue,
                            bStatus,
                            onReplaceValue,
                            onInvalidateValue
                        );
                }
            }
            // Documentation comment (if any)
            //
            setDocComment($value, docComment);
            
            // Tree span
            //
            endPos($value); 
        }   
    ;
    
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Enter into AST as an erroneous node
    //
    $value = F.at($pos).Erroneous(errNodes.elems);
    endPos($value);
    
 }
 
// ----------------
// Parameter lists.
// Parse the formal parameters of a function declaration and produce the
// corresponding AST. 
//
formalParameters

    returns [ListBuffer<F3Var> params = new ListBuffer<F3Var>()]      // Return type is a list of all the AST nodes that represent a 
                                                                        // formal parameter, this is used to generate the AST for the
                                                                        // funciton definition itself.
@init
{
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
}
    : LPAREN 
    
        (
            fp1=formalParameter 
    
            {
                // Capture the first parameter
                //
                params.append($fp1.var); 
            }
            (
                COMMA fp2=formalParameter
                
                    { 
                        // Second and subsequent parameter ASTs
                        //
                        params.append($fp2.var); 
                    } 
            )*
            COMMA?  
        )?
            
      RPAREN
    ;
    
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Because we have raised the error, we won't perform codegen, but we can
    // leave the list in tact so that the IDE has something to work with. The list
    // is optional, so even if we have gathered none, we are still good.
    //
 }
 
// -----------------
// Formal parameter.
// Parse the specification of an individual function parameter and
// produce the AST. Note that a parameter may be left empty
//
formalParameter

    returns [F3Var var]    // Formal parameters are contained in a F3 tree var node.
    
@init
{
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
}
    : name typeReference
    
        { 
            if ($name.inError) {
            
                // Looks like the name was missing, create an erroneous var instead
                // Build up new node in case of error
                //
                F3Expression part = F.at($name.pos).Ident($name.value);
                errNodes.append(part);
                endPos(part);
                errNodes.append($typeReference.rtype);
                
            } else {
            
                $var = F.at($name.pos).Param($name.value, $typeReference.rtype);
            }
            endPos($var); 
        }
    ;
    
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Because both name and typeReference will recover with something
    // sensible, we don't ned to create anything here. In theory, we can't
    // even get here.
    //
 }
 
// ------
// block.
// A block component is actually a unit that returns a value, it is an expression.
// In certain contexts the braces are more lexigraphically significant, such as the
// boundaires of if blocks. Hence those contexts specify the block directly rather than
// leaving the expression statement to pick it up.
//
// This means that a statement such as:
//
// if (x) { y} -z
//
// Does not consume the { y } -z as a complete expression but does
// what a programmer intuitively expects and uses only {y } as the
// subject of the if, with -z being a separate expression statement.
//
// A programmer can treat the above construct as a single expression
// by enclosing it in braces:
//
// if (x) { { y } -z }
//
// Which is then obvious. This also improves error recovery possibilities,
// which is a requirement for code completion utilities and so forth.
//
// Accepts an incoming character so that the block node can be created to
// include a prior token suchas 'finally' or 'try' etc.
//
block [ int inPos]

    returns [F3Block value]    // The block expression has a specialized node inthe F3 tree

// Where the error routines should append any errors
//
scope errorStack;

@init { 

    // A list of all the statement ASTs that make up the block expression
    //
    ListBuffer<F3Expression> stats = new ListBuffer<F3Expression>(); 
    
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    $errorStack::ASTErrors          = stats;

    // Start of rule for error node production/
    //
    int rPos = pos();
    if ($inPos != -1)
    {
        rPos = $inPos;
    }
    
    // Track the result expression of the block
    //
    F3Expression resultType = null;
}
    : LBRACE 
    
        // Eat up any garbled tokens, ready for the first valid statement
        //
        st1=syncBlock[resultType, stats] { resultType = $st1.value; }
        (
            blkValue=blockElement[resultType, stats]
                                                    
                                {                                   
                                    // This new statement is now the result type of the block
                                    //
                                    resultType = $blkValue.value;
                                }
                                
            
            // Eat up any garbled tokens, ready for another statement
            //  
            st2=syncBlock[resultType, stats] { resultType = $st2.value; }
        )*
    
        {   
            // If the result of the last element was erroneous, then
            // make the result of the block be void, which means the
            // result of the block will never be Erroneous, as the tree walkers
            // can't handle that.
            //
            if  (resultType instanceof F3Erroneous) {
                stats.append(resultType);
                resultType = null;
            }
            // Ensure that the result node is tracked in the endpos table
            //
            endPos(resultType);
        }
        
      RBRACE
        
        {
            
            $value = F.at(rPos).Block(0L, stats.toList(), resultType);
            endPos($value);
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Create an erroneousBlock, which is basically an Erroneous node
    // masquerading as a F3Block, unless we managed to gather any
    // useful statements, in which case constrcut the block and add the
    // erroneous node created by reportError call above. This will usually be
    // the case and helps the IDE a lot.
    //
            
    // If the result of the last element was erroneous, then
    // make the result of the block be void, which means the
    // result of the block will never be Erroneous, as the tree walkers
    // can't handle that.
    //
    if  (resultType instanceof F3Erroneous) {
        stats.append(resultType);
        resultType = null;
    }
        
    // Create the block
    //
    $value = F.at(rPos).Block(0L, stats.toList(), resultType);
    endPos($value);
 }

// ---------------------------- 
// Statement/Expression resync.
// If left to itself, the block rule cannot easilly resync to the start of a statement
// because we will throw an exception on trying to work out if we can insert or
// delete a token.
//
// If we use this rule after the open '{' and at the end of every complete/recoverable
// statement contained in a block, then it will be called unconditionally (it always
// matches the next token because it is the upsilon set). Most importantly, the followset
// stack will contain the follow set that is allowed to start a new statement. Hence our
// init rule just uses the trick of syncing to the next good statement, and throwing out
// any garbled expressions with a neat error. 
// 
// We record the token stream start position on rule entry, and upon rule exit
// if we consumed any tokens, then we add an Erroneous node to the AST and everyone is
// happy.
//
syncBlock[F3Expression returnType, ListBuffer<F3Expression> stats]

    returns [F3Expression value]
@init
{
    // Start of rule for error node production
    //
    int rPos    = pos();
    
    // Consume any garbled tokens that come before the next statement
    // or the end of the block. The only slight risk here is that the
    // block becomes MORE inclusive than it should but as the script is
    // in error, this is a better course than throwing out the block
    // when the error occurs and screwing up the whole meaning of
    // the rest of the token stream.
    //
    syncToGoodToken();
    
    // If we are going to accumulate an erroneous node in the block, then
    // we first need to accumulate the current block return value and then return
    // the error node as the new return value. We do not add the errneous block
    // to the stats here, the caller wil do it within its accumulation loop.
    //
    $value = $returnType;
}
@after
{
    // If we consume any tokens at this point then we create
    // an ERRONEOUS AST node for the IDE to monitor and add it
    // in to the staement list.
    //
    if  (rPos != pos()) {
    
        if  ($returnType != null) {
        
            // If we already had a return type, then
            // accumulate it, and the new error node
            // becomes the return value.
            //
            $stats.append($returnType);
        }
        
        // Span all the tokens we had to consume.
        //
        F3Erroneous errNode = F.at(rPos).Erroneous();
        endPos(errNode);
        $value = errNode;
                
        // Tell the script author where we think there is a screwed up expression
        //
        log.error(errNode, MsgSym.MESSAGE_F3_GARBLED_EXPRESSION);
    }
}
    :   // Deliberately match nothing, causing this rule always to be 
        // entered.
    ;
    
// -----------------
// Block expression
// A single element (statement/expression etc) of a block, separated
// into it's own rule so that erroneous statements do not abort the
// entire block.
//
blockElement [F3Expression val, ListBuffer<F3Expression> stats]

returns [F3Expression value] // All statements return an expression tree

@init
{
    // Start of rule for error node production/
    //
    int rPos    = pos();
    
    // Ensure we capture the current return value of the statement on an
    // error.
    //
    boolean statCaptured = false;
}
    : s=statement 
        {   
            // If the current statement is not the first one
            // then append the previous on to the list so that this current one
            // becomes the return value for the block. This logic leaves us with 
            // the AST for the last non-erroneous statement in the block
            // in our val variable, which we need to build the
            // AST for the block when we reach its end.
            //
            if  ($val != null) {
                $stats.append($val);
                statCaptured = true;
            }
            

            // The result of this rule becomes the type of the block, but
            // the caller will ensure that if this was an erroneous node,
            // that that does become the type of the block.
            //
            $value = $s.value;
        }
            possiblyOptSemi

    | SEMI  // Empty statements are just ignored, but the type must not be lost
    
        { $value = $val; }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);

    // Ensure that we don't lose the prior statement that was currently
    // the return value of the block;
    //
    if  ( !statCaptured &&  $val != null) {
        $stats.append($val);
    }
    
    // Create an erroneous node, which is basically an Erroneous node
    // masquerading as a F3Block.
    //
    $value = F.at(rPos).Erroneous();
    endPos($value);
 }
 
// -----------
// statements.
// Parse the set of elements that are viewed as programming statements. Note
// that this includes expressions, which are considered statements, or perhaps
// more accurately, statements are just other expressions.
// Note that each individual statement specifies whether it requires a
// terminating SEMI, or whether this is optional, or whether this is
// conditionally optional, such as the last statement of the script or
// brace block.
//
statement


    returns [F3Expression value] // All statements return an expression tree

@init
{   
    // Start of rule for error node production/
    //
    int rPos    = pos();
}
    : insertStatement       { $value = $insertStatement.value;                              }
    | deleteStatement       { $value = $deleteStatement.value;                              }
    | whileStatement        { $value = $whileStatement.value;                               }
        | (INVALIDATE expression)=>invalidateStatement      { $value = $invalidateStatement.value;                              }
    | BREAK                 { $value = F.at(pos($BREAK)).Break(null);       endPos($value); }
    | CONTINUE              { $value = F.at(pos($CONTINUE)).Continue(null); endPos($value); }
    | throwStatement        { $value = $throwStatement.value;                               }
    | returnStatement       { $value = $returnStatement.value;                              }
    | tryStatement          { $value = $tryStatement.value;                                 }
    | expression            { $value = $expression.value;                                   }
    ;

// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Here, we can only have got junk, as badly formed statement elements
    // will be caught in their own rules.
    //
    $value = F.at(rPos).Erroneous();
    endPos($value);
 }

// -----------  
// ON REPLACE.
// Parse an ON REPLACE clause which is an optional element of variable
// declarations and OVERRIDEs.
//
onReplaceClause

    returns [F3OnReplace value]    // onReplace has its own F3 Tree node type

@init
{
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    
    // Start of rule for error node production/
    //
    int rPos    = pos();
}
    : ON REPLACE oldv=paramNameOpt
                        { 
                            if  ($oldv.var != null)
                            {
                                errNodes.append($oldv.var);
                            }
                        }
    
        (
              (
                LBRACKET 
                    first=paramName 
                        { 
                            errNodes.append($first.var);
                        }
                    DOTDOT 
                    last=paramName 
                        { 
                            errNodes.append($last.var);
                        }
                RBRACKET
              )?
             
                 EQ newElements=paramName
                        { 
                            errNodes.append($newElements.var);
                        }
        )? 
        
    
        block [ -1 ]
        
        { 
            // Build the appropriate AST
            //
            $value = F.at(pos($ON)).OnReplace($oldv.var, $first.var, $last.var, $newElements.var, $block.value);
            endPos($value); 
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Construct an erroneous version of the expected class
    //
    $value = F.at(rPos).ErroneousOnReplace(errNodes.elems);
    endPos($value);
    
}

// -----------
// ON INVALIDATE.
// Parse an ON INVALIDATE clause which is an optional element of variable
// declarations and OVERRIDEs.
//
onInvalidateClause

    returns [F3OnReplace value]    // onReplace has its own F3 Tree node type

@init
{
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();

    // Start of rule for error node production/
    //
    int rPos    = pos();
}
    : ON INVALIDATE block [ -1 ]
        {
            // Build the appropriate AST
            //
            $value = F.at(pos($ON)).OnInvalidate($block.value);
            endPos($value);
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {

    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);

    // Construct an erroneous version of the expected class
    //
    $value = F.at(rPos).ErroneousOnInvalidate(errNodes.elems);
    endPos($value);

}
 
// ------------------
// Optional parameter
// Parse and construct an AST for optional parameters
//
paramNameOpt

    returns [F3Var var]    // Returns a F3Var tree node

    : paramName
        {
            { $var = $paramName.var; }
        }
    
    |   { $var = null; }
    ;
 
// ---------
// Parameter.
// Parse and construct the AST for a parameter
//
paramName

    returns [F3Var var]    // Returns a F3Var tree node

    : pn=name
        {
            
            // The recovery mechanisms will auto generate the IDENTIFIER
            // token, in the case that it can predict that it was just a single
            // token that the programmer forgot to use. Hence we must
            // pick up on that and generate a different node for a Missing
            // identifier.
            //
            if ($pn.inError || $pn.value == null) {
            
                $var = F.at($pn.pos).Param($pn.value, F.TypeUnknown()); 
                endPos($var, pos());
                
            } else {
            
                $var = F.at($pn.pos).Param($pn.value, F.TypeUnknown()); 
                endPos($var, $pn.pos + $pn.value.length());
            }
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
 }
    
// The ways in which a variable can be declared
//
variableLabel 
    
    returns [long modifiers, int pos] // returns the appropriate modifier flags and the position of the token
    
    : VAR           { $modifiers = 0L; $pos = pos($VAR); }
    | DEF           { $modifiers = F3Flags.IS_DEF; $pos = pos($DEF); }
    | LET { $modifiers = F3Flags.PUBLIC_INIT; $pos = pos($LET); } 
    | CONST { $modifiers = F3Flags.PUBLIC_INIT; $pos = pos($CONST); } 
    | VAL  { $modifiers = F3Flags.PUBLIC_INIT; $pos = pos($VAL); } 
    | ATTRIBUTE     {   $modifiers = 0L; 
                        $pos = pos($ATTRIBUTE); 
                        F3Erroneous err = F.at($pos).Erroneous();
                        endPos(err);
                        log.error(err, MsgSym.MESSAGE_F3_NOT_SUPPORTED_ATTRIBUTE); 
                    } 
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    $modifiers = 0L;
    $pos = semiPos();
 }
 
// ------   
// Throw.
// Parse the standard exception throwing mechanism.
//
throwStatement

    returns [F3Expression value]   // Returns the F3 Expression tree representing what we must throw
    
@init
{
    // Start of rule for error node production/
    //
    int rPos    = pos();
}
    : THROW expression
    
        { 
            // AST for the thrown expression
            //
            $value = F.at(pos($THROW)).Throw($expression.value);
            
            // Tree span
            //
            endPos($value);
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);

    // Now we need an error node
    //  
    $value = F.at(rPos).ErroneousThrow();
    endPos($value);
 }
 
// ---------------
// While statement
//
whileStatement
    
    returns [F3Expression value]   // Returns the F3 Expression tree representing the WHILE
    
@init
{
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    
    // Start of rule for error node production/
    //
    int rPos    = pos();
}
    : WHILE 
        LPAREN 
            expression 
                {
                    errNodes.append($expression.value);
                }
        RPAREN 
    
         loopVal=statement
            
        {
    
            // The AST for the WHILE, using either the block or statement
            //
            $value = F.at(pos($WHILE)).WhileLoop($expression.value, $loopVal.value);
            
            // Tree span
            //
            endPos($value);
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Create the erroneous node
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
    endPos($value);
 }
 
// -------
// INSERT.
// Parse the insert statement and produce the relevant AST
//
insertStatement  
    
    returns [F3Expression value]   // All steatemetns return a F3 expression tree
    
@init
{
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    
    // Start of rule for error node production/
    //
    int rPos    = pos();
    
}
    : INSERT elem=expression    { errNodes.append($elem.value); }
    
        (
              INTO eseq=expression
              
                {
                    errNodes.append($eseq.value);
                    
                    // Form 1, INTO
                    //
                    $value = F.at(pos($INSERT)).SequenceInsert($eseq.value, $elem.value, null, false);
                }
                
            | BEFORE isfi=indexedSequenceForInsert
            
                {
                    if ($isfi.seq != null) errNodes.append($isfi.seq);
                    if ($isfi.idx != null) errNodes.append($isfi.idx);
                                        
                    // Form 2, BEFORE
                    //
                    $value = F.at(pos($INSERT)).SequenceInsert($isfi.seq, $elem.value, $isfi.idx, false);
                }
                
            | AFTER isfi=indexedSequenceForInsert
            
                {
                    if ($isfi.seq != null) errNodes.append($isfi.seq);
                    if ($isfi.idx != null) errNodes.append($isfi.idx);
                    
                    // Form 3, AFTER
                    //
                    $value = F.at(pos($INSERT)).SequenceInsert($isfi.seq, $elem.value, $isfi.idx, true);
                }
        )

        {
            // Tree span
            //
            endPos($value);
        }  
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Create the erroneous node
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
    endPos($value);
    
 }
 
// ----------------
// Insert seqeunce.
// Parse the syntax for an insert sequence specified by the 
// INSERT BEFORE and INSERT AFTER variants.
//
indexedSequenceForInsert

    returns [F3Expression seq, F3Expression idx]

@init
{
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    
    // Start of rule for error node production/
    //
    int rPos    = pos();
}

    : primaryExpression             
    
        {
            // Sequence expression
            //
            $seq = $primaryExpression.value;
        }
        
      LBRACKET expression 
      
        {
            // Index expressions
            //
            $idx = $expression.value;
            errNodes.append($expression.value);
        }
        
      RBRACKET
            
    ;

// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Only index can throw us out here really
    // Create the erroneous node
    //
    $idx = F.at(rPos).Erroneous(errNodes.elems);
    endPos($idx);
 }
 
// -----------------    
// DELETE statement.
// Parse the DELETE statement forms and return the appropriate AST
//
deleteStatement  

    returns [F3Expression value]   // Delete returns a F3 Expression tree
    
@init
{
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    
    // Start of rule for error node production/
    //
    int rPos    = pos();
}
    : DELETE e1=expression
    
        {
            errNodes.append($e1.value);
        }

       ( 
              (FROM)=>FROM e2=expression
                
                {
                    $value = F.at(pos($DELETE)).SequenceDelete($e2.value,$e1.value);
                }
                
            | /* indexed and whole cases */
            
                {
                    $value = F.at(pos($DELETE)).SequenceDelete($e1.value);
                }
                
       )
       
       {
            // Tree span
            //
            endPos($value);
       }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Create the erroneous node
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
    endPos($value);
 }

// -----------------
// INVALIDATE statement.
// Parse the INVALIDATE statement forms and return the appropriate AST
//
invalidateStatement

    returns [F3Expression value]   // Delete returns a F3 Expression tree

@init
{

    // Start of rule for error node production/
    //
    int rPos    = pos();
}
    : INVALIDATE e1=expression

            {
                    $value = F.at(pos($INVALIDATE)).Invalidate($e1.value);
            }
    ;
// Catch an error. We create an erroneous node for anything that was at the start
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {

    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);

    // Create the erroneous node
    //
    $value = F.at(rPos).Erroneous();
    endPos($value);
 }
 
// -----------------
// RETURN statement.
// Parse the return statement forms and produce the relevant AST
//
returnStatement

    returns [F3Expression value]   // RETURN returns a F3 Expression tree
@init
{
    // Start of rule for error node production/
    //
    int rPos    = pos();
}
    : RETURN 
        
        (
              expression        
              
                {   
                    $value = F.at(pos($RETURN)).Return($expression.value);  
                }
                
            | (possiblyOptSemi)=>possiblyOptSemi    // Can't have a SEMI be optional here as we must eitehr consume
                                                    // the next expression or not.
                {   
                    $value = F.at(pos($RETURN)).Return(null);               
                }
                
        )
        
        {
            // Tree span
            //
            endPos($value);
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Create the erroneous node
    //
    $value = F.at(rPos).Erroneous();
    endPos($value);
 }
 
// -----------------------------
// TRY..CATCH..FINALLY seqeunce.
// Parse and build the AST for the stabdard try sequence
// TODO: Come back and relax the syntax requirements so as to catch malformed structure at semantic level
//       I.E. "Too many finally claues for try at nnn"
//
tryStatement

    returns [F3Expression value]   // returns a F3 Expression tree
    
@init
{
    // AST for any catch clauses
    //
    ListBuffer<F3Catch> caught = ListBuffer.lb();

    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();

    // Start of rule for error node production/
    //
    int rPos    = pos();
    
    // Count the number of finally clauses
    //
    int finallyCount = 0;
    
    // Count the number of catch clauses
    //
    int catchCount = 0;
    
    // Only error out on finally/catch out of sequence fo rthe first out
    // of sequence error.
    //
    boolean showSequenceErr = true;
    
    // Record start postion of finally clauses for correct error
    // position.
    //
    int fPos = 0;
    
}
    : TRY block [-1]
            { 
                errNodes.append($block.value); 
            }
        ( 
        
            // Predicate is neccessary to disambiguate associated catch and finally
            // blocks from orphaned blocks handled in alts 2 and 3 of the main rule
            //
            (CATCH|FINALLY)=>
        
            (
                  { 
                    // Record input positoni in case of error.
                    //
                    fPos = pos();
                  }
                    f1=finallyClause    
                    
                    { 
                        errNodes.append($f1.value); 
                    
                        if  (finallyCount != 0) {
                    
                            // Can only have one finally clause, so log an error
                            //
                            log.error($f1.value, MsgSym.MESSAGE_F3_FINALLY_TOOMANY);
                        }
                        finallyCount++; 
                    }
              
                | (
                    catchClause
                    
                    {
                        if  (finallyCount != 0 && showSequenceErr)  {
                        
                            // We came across a catchClause, but we have already seen the finally clause.
                            // We only error out the first time we detect the error so we don't throw
                            // the same error for each catch clause that is out of order.
                            //
                            showSequenceErr = false;
                            log.error($f1.value, MsgSym.MESSAGE_F3_FINALLY_NOTLAST);
                        }
                        // Accumulate the catch clauses
                        //
                        caught.append($catchClause.value);
                        errNodes.append($catchClause.value);
                        catchCount++;
                    }
                  )                 
            ) 
        )*
        
        {
            // Now - check for malformed constructs and make the AST node or the
            // erroneous node as appropriate
            //
            if  (catchCount == 0 && finallyCount == 0)
            {
                // We must see at least one catch or one finally, or we can't build
                // the AST
                //
                $value = F.at(pos($TRY)).Erroneous(errNodes.elems);
                endPos($value);
                log.error($value, MsgSym.MESSAGE_F3_BAD_TRY);
                
            } else {
            
                // Build the AST
                //
                $value = F.at(pos($TRY)).Try($block.value, caught.toList(), $f1.value);
            
                // Tree span
                //
                endPos($value);
            }
        }
    
        // Erroneouds constructs
        //
    |   fe=finallyClause
    
            {
                // Dangling finally clause belongs to no try block
                //
                errNodes.append($fe.value);
                $value = F.at(rPos).Erroneous(errNodes.elems);
                endPos($value);
                log.error($value, MsgSym.MESSAGE_F3_ORPHANED_FINALLY);
            }
            
    |   ce=catchClause

            {
                // Dangling catch clause belongs to no try block
                //
                errNodes.append($ce.value);
                $value = F.at(rPos).Erroneous(errNodes.elems);
                endPos($value);
                log.error($value, MsgSym.MESSAGE_F3_ORPHANED_CATCH);
            }

    ;
    
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Create the erroneous node
    //
    $value = F.at(rPos).Erroneous();
    endPos($value);
 }
 
// -------
// FINALLY
// Parse the finally clause of a trey...catch...finally sequence
//

finallyClause

    returns [F3Block value] // returns a F3 Expression tree

@init
{
    // Start of rule for error node production/
    //
    int rPos    = pos();
}
    : FINALLY block [rPos]
    
        {
            $value = $block.value;
            endPos($value);
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // The only thing we can have happen is that there was no block, so there
    // can be no nodes to catch
    //
    $value = F.at(rPos).ErroneousBlock();
    endPos($value);
}
 
// ------
// CATCH.
// Parse a catch clause of a try...catch...finally
//
catchClause

    returns [F3Catch value]    // Catch has its own F3 tree node type

@init
{
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    
    // Start of rule for error node production/
    //
    int rPos    = pos();
}
    : CATCH 
        LPAREN 
            formalParameter 
                {
                    errNodes.append($formalParameter.var);
                }
        RPAREN 
            block[-1]
    
        {
            $value = F.at(pos($CATCH)).Catch($formalParameter.var, $block.value);
            endPos($value);
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Errnoeous node
    //
    $value = F.at(rPos).ErroneousCatch(errNodes.elems);
    endPos($value);
}
 
// ---------------------
// Boundable expression.
// Used to parse expressions that can be bound to a variable.
//
boundExpression 

    returns [F3BindStatus status, F3Expression value]  // We need to return a status flag to say how and if the
                                                            // expression is bound, and the AST for the expression itself.

@init 
{ 
    boolean isBidirectional = false;    // Signals presence of INVERSE

    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    
    // Start of rule for error node production/
    //
    int rPos    = pos();
}

    : BIND 
      
      ( LAZY
            {
                // Ignore
                //TODO: warning
            }
      )?
      
      e1=expression 
    
        {
            errNodes.append($e1.value); // For erroneous node
        }
    
            (
                (WITH)=>WITH 
                
                    // Future syntax: (expression AS)?
                
                     INVERSE
                
                {
                    // Update status
                    //
                    isBidirectional = true;
                }
            )?
            
            {
                // Set up the bound expression
                //
                $value  = $e1.value;
                
                // Update the status
                //
                $status = isBidirectional? BIDIBIND : UNIDIBIND;
            }
    
    | e2=expression
    
        {
            // Unbound expression AST
            //
            $value  = $e2.value;
            
            // Update the status
            //
            $status = UNBOUND;
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Signal as if unbound
    //
    $status = UNBOUND;
    
    // Create the erroneous node
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
    
    // We discovered nothing in the list and so the endpos
    // is the same as the rule start position.
    endPos($value);
}

// -----------
// expression.
// General expression parse and AST build.
//
expression

    returns [F3Expression value]   // Expression has its own dedicated F3 tree node type
 
 @init
 {
    // Used for error reporting
    //
    int rPos = pos();
 }
    : ifExpression

        {
            $value = $ifExpression.value;
        }
                
    | forExpression     

        {
            
            $value = $forExpression.value;
        }
        

        
    | assignmentExpression

        {
            $value = $assignmentExpression.value;
        }
        
    | // Expressions can parse variable declarations at all levels
      // both local, script, class etc. It is up to the attribution phase
      // to throw out modifiers where they are not allowed such as on 
      // local variable declarations.
      //
      m=modifiers 
        
        variableDeclaration [$m.mods, $m.pos]
    
        {
            $value = $variableDeclaration.value;
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);

    // An error at this point in the expression tree means we
    // will not have anythig to accumulate for an erroneous node
    // so we span from the start to the recovery point.
    //
    $value = F.at(rPos).Erroneous();
    endPos($value);
}

// ------------------------
// FOR statement/expression
//
forExpression

    returns [F3Expression value]   // All statements are expressions

@init
{
    // In clause accumulator
    //
    ListBuffer<F3ForExpressionInClause> clauses = ListBuffer.lb();

    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();

    // Used for error reporting
    //
    int rPos = pos();

}
    : FOR 
        LPAREN 
        
            i1=inClause         
                {  
                    clauses.append($i1.value); 
                    errNodes.append($i1.value); // For erroneous node
                }
            (COMMA i2=inClause  
                    {  
                        clauses.append($i2.value); 
                        errNodes.append($i2.value); // For erroneous node
                    } 
            )* 
            
        RPAREN 
        
        statement
                
            {
                errNodes.append($statement.value); 
                $value = F.at(pos($FOR)).ForExpression(clauses.toList(), $statement.value);
            }
        
        {
            // Tree span
            //
            endPos($value);
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Though we seemed to start out down a FOR statement, there was an error
    // that we could not recover from by simple insert/delete token, so we
    // span the erroneous trees
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
    endPos($value);
}

// ----------
// IN clause.
// Parse an individual IN clause of a FOR statement.
//
inClause

    returns [F3ForExpressionInClause value]    // Dedicated AST tree node

@init
{
    // Assume no WHERE expression
    //
    F3Expression weVal = null;
    
    // Start postion
    //
    int sPos = pos();
    
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    F3Expression comonadVal = null;
    F3Var var2 = null;
}

    : (formalParameter IN)=>(f1=formalParameter   { errNodes.append($f1.var);    }
        IN 
        se=expression   { errNodes.append($se.value);               }

        (
              WHERE we=expression   { weVal = $we.value; errNodes.append($we.value); }
            |
        )
        
        {
            $value = F.at(sPos).InClause($f1.var, $se.value, weVal);
            endPos($value); 
        })
|
     e2=expression INTO f3=formalParameter (IN f4=formalParameter { var2 = $f4.var ;} )?
        (
              WHERE we2=expression   { weVal = $we2.value; errNodes.append($we2.value); }
            |
        )
        {
            $value = F.at(sPos).InClause(var2, e2, weVal, $f3.var);
            endPos($value); 
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // But we create an Erroneous version of the node
    //
    $value = F.at(sPos).ErroneousInClause(errNodes.elems);
    endPos($value);
}

// -----------------------
// If Then Else expression
//
ifExpression 

    returns [F3Expression value]   // The expression tree that represents the If expression
    
@init
{
    // Statement or block expression
    //
    F3Expression sVal = null;
    
    // Else expression (if present)
    //
    F3Expression eVal = null;
    
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    
    // Used for error reporting
    //
    int rPos = pos();

}
    : IF LPAREN 
    
            econd=expression    { errNodes.append($econd.value);    }
            
        RPAREN 
    

        THEN?  statement            { sVal = $statement.value;  errNodes.append(sVal);  }
            
            (
                (ELSE)=>e1=elseClause   { eVal = $e1.value; errNodes.append(eVal);  }
            )?
            
        {
            // The IF AST
            //
            $value = F.at(pos($IF)).Conditional($econd.value, sVal, eVal);
            
            // Tree span
            //
            endPos($value);
            
        }
        
    | // Deliberately allow an orphaned else (non-orphaned ones will be
      // pick ed up by the IF clause above) so it can be parsed an attributed
      // for the AST (downstream tools may require this), but then throw it
      // out as being orphaned.
      //
      ee=elseClause
      
        {
            // Accumulate for the error node
            //
            errNodes.append($ee.value);
            $value = F.at(rPos).Erroneous(errNodes.elems);
            endPos($value);
            
            // Tell the script author (and the IDE) about their issue
            //
            log.error($value, MsgSym.MESSAGE_F3_ORPHANED_ELSE);
        }
    
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // But we create an Erroneous version of the node
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
    endPos($value);
}

// -----------
// Else clause
// Parse the else expression of an if statement
//
elseClause

    returns [F3Expression value]   // The expression tree that represents the Else expression
@init
{
    // Used for error productiions
    //
    int rPos = pos();
}
    : ELSE 
        (
            statement           { $value = $statement.value;    }
        )
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // We can only get an error here if we had an ELSE clause but
    // the statement was missing or we could not reach it for too much 
    // junk, so nothing to put in the errornode
    //
    $value = F.at(rPos).Erroneous();
    endPos($value);
}   

// -----------
// Assignment.
// Parse and produce teh AST for an assignement expression. Note
// that name of this rule is a slight misnomer. It might encapsulate
// an assignment, but it might be just a straight expression.
//
assignmentExpression  

    returns [F3Expression value]   // The expression tree that represents the assignment expression

@init
{
    // Work out current position in the input stream
    //
    int rPos = pos();
    
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
}
    : lhs=assignmentOpExpression 
            {
                errNodes.append($lhs.value);    // For error production
            }
        (     
              (EQ)=> EQ rhs=expression
              
                {
                    // This is actually an assign
                    //
                    $value = F.at(rPos).Assign($lhs.value, $rhs.value);
                    
                    // Tree span
                    //
                    endPos($value);
                }
                
            |   // Just an expression without an assignment
                //
                {
                    $value = $lhs.value;
                }
        )
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Create an Erroneous version of the node
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
    endPos($value);
}

assignmentOpExpression

    returns [F3Expression value]   // The expression tree that represents the assignment expression

@init
{
    // Work out current position in the input stream
    //
    int rPos = pos();

    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();

}

    : lhs=orExpression          { errNodes.append($lhs.value); }        
      
        (     assignOp rhs=expression
        
                {
                    // AST for assignement
                    //
                    $value = F.at(rPos).Assignop($assignOp.op, $lhs.value, $rhs.value);
                }
                
            | SUCHTHAT 
                such=orExpression { errNodes.append($such.value); }
            
                    (
                        (TWEEN)=>TWEEN i=orExpression
                    )?
            
                {
                    // AST FOR Interpolation
                    //
                    $value = F.at(rPos).InterpolateValue($lhs.value, $such.value, $i.value);
                    
                }
            
            |   { 
                    // AST for expressions
                    //
                    $value = $lhs.value; 
                }   
       )
       
       {
            // AST Span
            //
            endPos($value);
       }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);

    // Create an Erroneous version of the node
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
    endPos($value);
    
}

// -----------------
// Assign operators
// All the operators that involve assignments.
//  
assignOp

    returns [F3Tag op]  // Returns the operation token that we find
    
    : PLUSEQ        { $op = F3Tag.PLUS_ASG;             }
    | SUBEQ         { $op = F3Tag.MINUS_ASG;            }
    | STAREQ        { $op = F3Tag.MUL_ASG;              }
    | SLASHEQ       { $op = F3Tag.DIV_ASG;              }
    | PERCENTEQ
        { 
            // Create an error node for a DiagnosticPosition
            //
            F3Erroneous err = F.at(pos($PERCENTEQ)).Erroneous();
            endPos(err);
            log.error(err, MsgSym.MESSAGE_F3_BAD_PERCENT);
            
            // Erroneous operator
            //
            $op = F3Tag.ERRONEOUS;
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
}

// -------------
// OR opertator
// LL(k) OR precedence
//
orExpression

    returns [F3Expression value]   // Expression tree for OR
        
@init
{
    // Work out current position in the input stream
    //
    int rPos = pos();
    
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();

}

    :   e1=andExpression
            
            {
                $value = $e1.value;
                errNodes.append($e1.value);
            }
            ( 
                OR e2=andExpression
                
                {
                    $value = F.at(rPos).Binary(F3Tag.OR, $value, $e2.value);
                    endPos($value);
                }
            )*
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Create an Erroneous version of the node
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
    endPos($value);
}

// -----------
// AND operator
// LL(k) AND precedence
//
andExpression

    returns [F3Expression value]   // Expression tree for AND
        
@init
{
    // Work out current position in the input stream
    //
    int rPos = pos();
    
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
}

    : e1=typeExpression

        {
            $value = $e1.value;
            errNodes.append($e1.value);
        }
        ( 
            AND e2=typeExpression 
            
            {
                $value = F.at(rPos).Binary(F3Tag.AND, $value, $e2.value);
                endPos($value);
            }
        )*
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Create an Erroneous version of the node
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
    endPos($value);
}

// ----------------
// Typed expression
// LL(k) precedence
//
typeExpression 

    returns [F3Expression value]   // Expression tree for typed expressions
        
@init
{
    // Work out current position in the input stream
    //
    int rPos = pos();
    
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
}

    : relationalExpression      { errNodes.append($relationalExpression.value); }

        (
              INSTANCEOF itn=type
            
                {
                    $value = F.at(pos($INSTANCEOF)).TypeTest($relationalExpression.value, $itn.rtype);
                    endPos($value);
                }

	     | OF ga=genericArguments
                {
		    $value = F.at(pos($OF)).TypeApply($relationalExpression.value, ga);
		    endPos($value);

		 }

            | AS atn=type
            
                {
                    $value = F.at($relationalExpression.value.pos).TypeCast($atn.rtype, $relationalExpression.value);
                    endPos($value);
                }
            
            |   {
                    $value = $relationalExpression.value;
                }
       )
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);

    // Create an Erroneous version of the node
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
    endPos($value); 
}

// -----------
// Relationals
// LL(k) precedence
//  
relationalExpression  

    returns [F3Expression value]   // Expression tree for typed expressions
        
@init
{
    // Work out current position in the input stream
    //
    int rPos = pos();
    
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
}

    : a1=additiveExpression { $value = $a1.value; errNodes.append($a1.value); }
        (
            
            relOps   a2=additiveExpression
                
                {
                    $value = F.at(rPos).Binary($relOps.relOp, $value, $a2.value);
                    endPos($value);
                }
        )* 
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);

    // Create an Erroneous version of the node
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
    endPos($value); 
}

// ---------------------
// Relational operators.
// LL(k) precedence, all operators are same precedence
//
relOps

    returns [F3Tag relOp]   // Returns the F3 operator type
    
    : LTGT
        { 
            F3Erroneous err = F.at(pos($LTGT)).Erroneous();
            endPos(err);
            $relOp = F3Tag.NE;
            log.error(err, MsgSym.MESSAGE_F3_NOT_NE);
        }   
                    
    | NOTEQ  { $relOp = F3Tag.NE;   }
    | EQEQ   { $relOp = F3Tag.EQ;   }
    | LTEQ   { $relOp = F3Tag.LE;   }
    | GTEQ   { $relOp = F3Tag.GE;   }
    | LT     { $relOp = F3Tag.LT;   }
    | GT     { $relOp = F3Tag.GT;   }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
}

// ---------------------
// Arithmetic operations
// LL(k) precedence.
//  
additiveExpression 

    returns [F3Expression value]   // Expression tree for additive expressions
        
@init
{
    // Work out current position in the input stream
    //
    int rPos = pos();
    
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();

}
    : m1 = multiplicativeExpression   
        { 
            $value = $m1.value; 
            errNodes.append($m1.value);
        }
        (
            (arithOps)=>
                
                arithOps   m2=multiplicativeExpression

            {
                $value = F.at(rPos).Binary($arithOps.arithOp , $value, $m2.value);
                endPos($value);
            }
        )* 
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Create an Erroneous version of the node
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
    endPos($value);
}

// --------------------
// Arithmetic operators
//
arithOps

    returns [F3Tag arithOp] // Returns the F3 operator type
    
    : PLUS      { $arithOp = F3Tag.PLUS;    }
    | SUB       { $arithOp = F3Tag.MINUS;   }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
}

// --------------------------
// Multiplicative expressions
// LL(k) precedence emboides all operators at the same precednce as MUL
//  
multiplicativeExpression

    returns [F3Expression value]   // Expression tree for additive expressions
        
@init
{
    // Work out current position in the input stream
    //
    int rPos = pos();

    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();

}
    : u1=unaryExpression    { $value = $u1.value; errNodes.append($u1.value); }
        (
            { rPos = pos(); }   // Use operator as position for AST
            
            multOps u2=unaryExpression
                
                {
                    $value = F.at(rPos).Binary($multOps.multOp, $value, $u2.value);
                    endPos($value);
                }
       )* 
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Create an Erroneous version of the node
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
    endPos($value);
}

// -------------------------
// Multiplicative operators.
// LL(k) precedence - incorporates any other operators at this precedence
//
multOps

    returns [F3Tag multOp]  // Returns the F3 operator type
    
    : STAR      { $multOp = F3Tag.MUL;  }
    | SLASH     { $multOp = F3Tag.DIV;  }
    | PERCENT   
            
        {
            F3Erroneous err = F.at(pos($PERCENT)).Erroneous();
            endPos(err);
            $multOp = F3Tag.MOD;
            log.error(err, MsgSym.MESSAGE_F3_BAD_PERCENT);
        }   
             
    | MOD       { $multOp = F3Tag.MOD;  }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);

}

// -----------------    
// Unary expressions
// LL(k) Precedence
//
unaryExpression

    returns [F3Expression value]   // Expression tree for unary expressions

@init
{
    // Work out current position in the input stream
    //
    int rPos = pos();
    
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
}

    : se=suffixedExpression

        {
            errNodes.append($se.value);
            $value = $se.value;
        }
        
    | INDEXOF       id=identifier
    
        {   
            $value = F.at(rPos).Indexof($id.value);
            endPos($value);
        }
        
    | (SUB DECIMAL_LITERAL)=> SUB        DECIMAL_LITERAL

        {
            $value = F.at(rPos).LiteralInteger('-' + $DECIMAL_LITERAL.text, 10);
            endPos($value);
        }

    | unaryOps      e=unaryExpression

        {
            $value = F.at(rPos).Unary($unaryOps.unOp, $e.value);
            endPos($value);
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);

    // Create an Erroneous version of the node
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
    endPos($value);
}

// -------------------------
// Unary operators.
// LL(k) precedence
//
unaryOps

    returns [F3Tag unOp]    // Returns the F3 operator type
    
    : SUB           { $unOp = F3Tag.NEG; }
    | NOT           { $unOp = F3Tag.NOT; }
    | SIZEOF        { $unOp = F3Tag.SIZEOF; }
    | PLUSPLUS      { $unOp = F3Tag.PREINC; }
    | SUBSUB        { $unOp = F3Tag.PREDEC; }
    | REVERSE       { $unOp = F3Tag.REVERSE; }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
}

// ------------------
// Postfix operations
// LL(k) precedence
//
suffixedExpression 

    returns [F3Expression value]   // Expression tree for suffix expressions

@init
{
    // Work out current position in the input stream
    //
    int rPos = pos();
    
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
}

    : pe=postfixExpression  { errNodes.append($pe.value); }
        ( 
              { input.LT(-1).getType() != RBRACE }?=> PLUSPLUS
              
                {
                    $value = F.at(rPos).Unary(F3Tag.POSTINC, $pe.value);
                    endPos($value);
                }
                
            | { input.LT(-1).getType() != RBRACE }?=> SUBSUB
            
                {
                    $value = F.at(rPos).Unary(F3Tag.POSTDEC, $pe.value);
                    endPos($value);
                }
                
            | { $value = $pe.value; }
        )
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Create an Erroneous version of the node
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
    endPos($value);
}

// ------------------------
// Postfix-able expressions
// LL(k) precedence
//
postfixExpression 

    returns [F3Expression value]   // Expression tree for suffix expressions

@init
{
    // Work out current position in the input stream
    //
    int rPos = pos();
    int sPos = rPos;

    // Position for pipe epxression
    //
    int pPos = -1;
    
    // Indicates if we had the LT token
    //
    int clusiveType = SequenceSliceTree.END_INCLUSIVE;
    
    // Last element of sequence (if present)
    //
    F3Expression   lastExpr = null;
    
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
}

    : pe=primaryExpression  { $value = $pe.value; errNodes.append($pe.value); }
    
        (
              dot=(DOT|NULLCHECK)
                ( 
                      (CLASS)=>CLASS 
                    
                        {
                            Name cName = Name.fromString(names, "class"); 
                            $value = F.at(pos($dot)).Select($value, cName, $dot.getType()==NULLCHECK);
                            endPos($value);
                            errNodes.append($value);
                        }
                        
                    | n1=nameAll
                      
                      {
                            $value = F.at(pos($dot)).Select($value, $n1.value, $dot.getType()==NULLCHECK);
                            endPos($value);
                            errNodes.append($value);
                      }
                       
                )

            | (LPAREN)=>LPAREN 

                    expressionList 
            
                {
                    $value = F.at(sPos).Apply(null, $value, $expressionList.args.toList());
                    errNodes.append($value);
                    
                }
                RPAREN
                {
                    endPos($value);
                }
                
            | (LBRACKET)=>l1=LBRACKET
            
                {
                    // INit our flags
                    //
                    clusiveType = SequenceSliceTree.END_INCLUSIVE;
                    lastExpr    = null;
                }
    
                (
                      n2=name 
                        {
                            // Build up new node in case of error
                            //
                            F3Expression part = F.at($n2.pos).Ident($n2.value);
                            errNodes.append(part);
                            endPos(part);
                            pPos = part.getEndPosition(endPositions);
                        }
                      
                      PIPE 
                      
                      { rPos = pos(); } // Use expression as position for AST
                      
                      e1=expression r3=RBRACKET
                      
                      {
                        errNodes.append($e1.value);
                        
                        // Build a list of clauses as AST builder expects this
                        //
                        ListBuffer<F3ForExpressionInClause> clauses = ListBuffer.lb();
                        
                        // Build a var reference
                        //
                        F3Var var = F.at($n2.pos).Param($n2.value, F.TypeUnknown());
                        endPos(var, pPos);
                        
                        // Set up the in clause
                        //
                        clauses.append(F.at(pos($l1)).InClause(var, $value, $e1.value));
                        
                        // Predicate needs identifier AST
                        //
                        $value = F.at(sPos).Predicate(clauses.toList(), F.at($n2.pos).Ident($n2.value));
                        
                        // Tree span
                        //
                        endPos($value, pos($r3));
                      }
                      
                    | first=expression  { errNodes.append($first.value); }
                            
                        (
                              r1=RBRACKET
                              
                                {
                                    // Use left bracket as AST start pos
                                    //
                                    $value = F.at(sPos).SequenceIndexed($value, $first.value);
                                    
                                    // Use right bracket as AST end pos
                                    //
                                    endPos($value);
                                }
                                
                            | DOTDOT 
                                (
                                      (LT { clusiveType = SequenceSliceTree.END_EXCLUSIVE; } )? 
                                        (
                                            last=expression
                                            {
                                                errNodes.append($last.value);
                                                lastExpr = $last.value;
                                            }
                                        )?
                                        
                                )
                                
                              r2=RBRACKET
                              
                              {
                                // If we have LT, then this is an exclusive slice
                                //
                                $value = F.at(sPos).SequenceSlice
                                                                (
                                                                    $value,
                                                                    $first.value,
                                                                    lastExpr,
                                                                    clusiveType
                                                                );
                                endPos($value);
                              }
                        )
                )
        )* 
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);

    // Create an Erroneous version of the node
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
    endPos($value);
}

// -------------------
// Primary expressions
// LL(k) precedence - primitives which cannot be reduced other
// than to atoms.
//  
primaryExpression  

    returns [F3Expression value]   // Expression tree for primary expressions

@init
{
    // Work out current position in the input stream
    //
    int rPos = pos();
    
    // Use to build a list of objectLiteral parts.
    //
    ListBuffer<F3Tree> parts = ListBuffer.<F3Tree>lb();

    // Used to construct time literal expression
    //
    F3Expression sVal = null;

    ListBuffer<F3Expression> eList = new ListBuffer<F3Expression>();

    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();   
    com.sun.tools.mjavac.util.List<F3Expression> genericArgs = null;
}
    : qualname ((OF)=>(OF gas=genericArguments) { genericArgs = $gas.value; })?
        {
            if (genericArgs != null) {
                $value = F.at($qualname.value.pos).Ident($qualname.value, genericArgs);
            } else {
                $value = $qualname.value;
            }
            errNodes.append($value);
        }
        (
            (LBRACE)=>LBRACE  
                
                    o1=objectLiteral
                    
            RBRACE
                  
                {
                    // AST
                    //
                    $value = F.at(rPos).ObjectLiteral($value, $o1.parts.toList());
                    
                    // Tree span
                    //
                    endPos($value);
                }
            |
        )

    | THIS

        {
            $value = F.at(pos($THIS)).Ident(names._this);
            endPos($value);
        }
        
    | SUPER
    
        {
            $value = F.at(pos($SUPER)).Ident(names._super);
            endPos($value);
        }
        
    | se=stringExpression

        {
            $value = $se.value;
        }
        
    | be=bracketExpression
    
        {
            $value = $be.value;
        }
        
    | block [-1]
    
        {
            $value = $block.value;
        }
        
    | literal
    
        {
            $value = $literal.value;
        }
        
    | fe=functionExpression
    
        {
            $value = $fe.value;
        }
    
    | LPAREN e=expression (e1=expression {eList.append(e1);})* RPAREN
    
        {
            if (eList.size() == 0) {
                $value = preserveTrees ?
                F.at(pos($LPAREN)).Parens($e.value) :
                $e.value;
                endPos($value);
            } else {
                $value = F.at(pos($LPAREN)).PartialApply($e.value, eList.toList());
            }
        }
        
    | AT 
        LPAREN 
            tv=timeValue
            {
                sVal = $tv.valNode;
                errNodes.append($tv.valNode);
            }
        RPAREN 
        LBRACE 
            k=keyFrameLiteralPart

        RBRACE
        
        {
            $value = F.at(rPos).KeyFrameLiteral(sVal, $k.exprs.toList(), null);
            endPos($value);
        }
    
    | newExpression

        {
            $value = $newExpression.value;
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);

    // If we were constructing an object literal or keyframe set, then
    // we will still create that, but an error node will have been added
    // to containing block or if there is no containing block, the script
    //
    if  ($o1.parts != null) {
    
        $value = F.at(rPos).ObjectLiteral($value, $o1.parts.toList());
    
    } else if ($tv.valNode != null && $k.exprs != null) {

        $value = F.at(rPos).KeyFrameLiteral(sVal, $k.exprs.toList(), null);

    } else {
        // Create an Erroneous version of the node
        //
        $value = F.at(rPos).Erroneous(errNodes.elems);

    }
            
    endPos($value); 
            
}

// ------------
// Frame values
//  
keyFrameLiteralPart

    returns [ListBuffer<F3Expression> exprs = new ListBuffer<F3Expression>(); ]   // Gathers a list of expressions representing frame values
    
    // Where to append erroneous nodes
    //
    scope errorStack;
    
@init
{

    // Work out current position in the input stream
    //
    int rPos = pos();
    
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    $errorStack::ASTErrors = exprs;
    
}
    : k1=expression             { exprs.append($k1.value);  }
    
        (SEMI SEMI* // This is a trick to force error recovery, otherwise SEMI+ forces an early exit exception
        
            k2=expression       { exprs.append($k2.value);  }
        )* SEMI*
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Any error messages will auto accumulate and erroneous node, so
    // we need do nothing here.
}

// -------------------
// Anonymous functions
//
functionExpression

    returns [F3Expression value]   // Expression tree for anonymous function
    
@init
{
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    
    // Rule pos in case of error
    //
    int rPos = pos();
    
    // Accumulate any generic arguments
    //
    ListBuffer<F3Expression> exprbuff = ListBuffer.<F3Expression>lb();

    F3Expression bodyExpr = null;
}
    :   (modifiers) => modifiers FUNCTION 
            ((OF | FORALL) gas=genericParams[false, false] { 
                exprbuff.appendList($gas.value);
            })?
    
        formalParameters    
            { 
                // Accumulate in case of error
                //
                for ( F3Tree t : $formalParameters.params) {
                    errNodes.append(t);
                }
            }
            
        typeReference   { errNodes.append($typeReference.rtype); }
        ((LBRACE) => (block   [-1]    { errNodes.append($block.value); }
    
        {
            // F3 AST
            //
            $value = F.at(pos($FUNCTION)).FunctionValue
                                (
                                    $modifiers.mods,
                                    exprbuff.toList(),
                                    $typeReference.rtype, 
                                    $formalParameters.params.toList(),
                                    $block.value
                                );
                                
            // Tree span
            //
            endPos($value);
        }
    |
        primaryExpression 
            {
            bodyExpr = $primaryExpression.value; 
            $value = F.at(pos($FUNCTION)).FunctionValue
                                (
                                    $modifiers.mods,
                                    exprbuff.toList(),
                                    $typeReference.rtype, 
                                    $formalParameters.params.toList(),
                                    F.at(pos($FUNCTION)).Block(0L, com.sun.tools.mjavac.util.List.<F3Expression>of(bodyExpr), null)
                                );
                                
            // Tree span
            //
            endPos($value);
            }
    
    ))
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Create an ERRONEOUS vode
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
    endPos($value);
}

// ---
// NEW
//
newExpression

    returns [F3Expression value]   // Expression tree for new expression

@init
{
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    
    // Rule pos in case of error
    //
    int rPos = pos();
}
    : NEW 
        typeName                { errNodes.append($typeName.value); }
        expressionListOpt
    
        {
            // If we got ehre, there wil lbe no errors for expressionListOpt, and if 
            // did not, then the expressionListOpt will not be built, so we do not accumulate
            // its nodes for error.
            //
            $value = F.at(pos($NEW)).InstanciateNew($typeName.value, $expressionListOpt.args.toList());
            endPos($value);
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);

    // Create an ERRONEOUS vode
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
    endPos($value); 
}

// ---------------
// Object literals
//
objectLiteral

    returns [ListBuffer<F3Tree> parts = ListBuffer.<F3Tree>lb()]  // Gather a list of all the object literal initializations

// Where to append erroneous nodes
//
scope errorStack;

@init
{
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    $errorStack::ASTErrors = parts;
    
    // Rule pos in case of error
    //
    int rPos = pos();
}
    :   (COMMA|SEMI)*   // Separators are optional and just syntactic sugar
    
        (       
            (
                oli=objectLiteralPart 
            
                {
                    parts.append($oli.value);
                }
            )
            
            (COMMA|SEMI)*   // Separators are optional and just syntactic sugar
            
            
        )*      // May be no elements in the object literal, just {}
    
                
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // The error message routines will have accumulated
    // any erroneous nodes, so we don't need ot do anythign here
    // but return. We don't want to throw the whole set into
    // error as we can be finer grained.
    //
    
}

// Individual components of an object literal
//
objectLiteralPart

    returns [F3Tree value]     // Expression tree for object literal elements

@init
{
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    
    // Rule pos in case of error
    //
    int rPos = pos();
    
}
    : (modifiers) => modifiers
        (
              variableDeclaration    [$modifiers.mods, $modifiers.pos]
              
                {
                    $value = $variableDeclaration.value;
                    errNodes.append($value);
                }
                
            | functionDefinition     [$modifiers.mods, $modifiers.pos]
            
                {
                    $value = $functionDefinition.value;
                    errNodes.append($value);
                }
        )
        
    | oli=objectLiteralInit
        
        {
            $value = $oli.value;
            errNodes.append($oli.value);
        }
    | boundExpression

        {
            // AST
            //
            $value = F.at(rPos).ObjectLiteralPart
                                    (
                                        null,
                                        $boundExpression.value,
                                        $boundExpression.status
                                    );
            endPos($value);
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Create an ERRONEOUS node
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
    endPos($value); 
}

// --------------------------       
// Object literal initializer
//  
objectLiteralInit

    returns [F3Tree value]     // Construct the AST for a name value pair
    
@init
{
    // Work out current position in the input stream
    //
    int rPos = pos();

    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    
    // Indicates that something went wrong with the parse
    //
    boolean inError = false;
}
    : n1=name
        {
            if  ($n1.inError || $n1.value == null) {
                
                // The rule caused an identifier to be made up
                //
                inError = true;
            }
                            
            // Build up new node in case of error
            //
            F3Expression part = F.at($n1.pos).Ident($n1.value);
            errNodes.append(part);
            endPos(part);
        } 
        COLON  
        boundExpression
    
        {
            if  (inError) {
            
                // Missing name, so throw this into error state
                //
                errNodes.append($boundExpression.value);
                
                // Create an ERRONEOUS node
                //
                $value = F.at(rPos).Erroneous(errNodes.elems);
                
            } else {
            
                // AST
                //
                $value = F.at($n1.pos).ObjectLiteralPart
                                        (
                                            $n1.value,
                                            $boundExpression.value, 
                                            $boundExpression.status
                                        );
            }
                                
            // Tree span
            //
            endPos($value);
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Create an ERRONEOUS node
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
    endPos($value); 

}

// -------  
// Strings
// F3 string expressions are more richly expressive than the more usual
// quoted strings.
//
// 1) A translation key may prefix string literals;
// 2) The string literal itself may consist of multiple parts, which are
//    concatenated at compile time, rather than run time.
//    I.E. ##"MyTransKey" "String part 1" "String part 2\n"
//    This allows for multi line string literals, built at compile time,
//    which gives the script author unambiguous control over
//    leading spaces, explict methods to insert new lines, and the ability to comment
//    individual components.
//    I.E. 
//      var myString =
//          "<header>"       // This is the header
//          "some stuff\n"   // Some stuff now, with a trailing newline
//          "  level 1\n"    // More stuff, with leading spaces and a traliing newline
//
// Overall this leads to better error recovery for the parser, while leaving
// the language syntax obvious to and clearly controlled by, the script author;
//
// Notes: 
//
// 1) Only string literals can be compounded in this way - expressions are
//    parsed here, but are thrown out with a semantic error explaining
//    that this is a compile time concept, not a runtime concept;
// 2) A single translation key prefix applys to the entire compound string.
//    Compound parts cannot be translated individually;
//
stringExpression 

    returns [F3Expression value]   // Expression tree for stringExpressions

scope {
    // Indicates that the expression went into a parse error state
    // somehere and we should not try to resolve it
    //
    boolean inError;
}

@init
{
    // Buffer in which to accumulate all string elements
    //
    ListBuffer<F3Expression> strexp = new ListBuffer<F3Expression>();
    
    // Translation key, if any, for the literal string
    //
    String translationKey = null;
    
    // Work out current position in the input stream
    //
    int rPos = pos();
    
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    
    // Start in non error state
    //
    $stringExpression::inError = false;
    
}

    : (
          (
            // Translation key is optional
            //
            TRANSLATION_KEY { translationKey = $TRANSLATION_KEY.text; } 
          )?
    
            // We must find at least one compound element to the string
            //
            strCompoundElement [ strexp ]
            
            (
                // After the first element, there may be any number of additional
                // elements, including zero. We must force the parser to take
                // the righteous path for syntactically correct constructs, then
                // error out semantically on anything else.
                //
                   (STRING_LITERAL|QUOTE_LBRACE_STRING_LITERAL) =>strCompoundElement [ strexp ]
            
            )*
      )
      
        {
            if  ($stringExpression::inError) {
            
                // Some part of this parse caused an error, so the whole lot just
                // accumulates into an error node.
                //
            
                // Accumulate whatever pieces we discovered
                //
                for (F3Tree t : strexp) {
    
                    errNodes.append(t);
                }
    
                // Create an ERRONEOUS node
                //
                $value = F.at(rPos).Erroneous(errNodes.elems);
                endPos($value); 
    
            } else {
            
                // AST for string expression
                // If we accumulated just a single entry then by definition
                // we accumulated just a simple string literal, but if there
                // is more than one entry, or there is a translation key,
                // then we have a string expression
                //
                if  (strexp.size() > 1 || translationKey != null)
                {
                    // Complex expression
                    //
                    $value = F.at(rPos).StringExpression(strexp.toList(), translationKey);
    
                    // Tree span
                    //
                    endPos($value);
    
                }
                else
                {
                    // This is an individual string literal, and is already endPos'ed
                    //
                    $value  = strexp.toList().get(0);
                }
            }           
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Accumulate whatever pieces we discovered
    //
    for (F3Tree t : strexp) {
    
        errNodes.append(t);
    }
    
    // Create an ERRONEOUS node
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
    endPos($value); 
    
}

// --------------------------------------------
// An individual component of a compound string
//
// When considering the elements accumulated by the 
// list buffer, assume this:
//
// 1) The list will either be a single element, in 
//    which case it is a single string literal, or
//    contain (3n)+1 elements where n is the number
//    expressions in the string {expr}. This is
//    because an expression consists of the leadin,
//    a format string and the expression, but there is
//    always one final element for the trailing part of
//    the string expression: "leading{\%format expr }trailing"
// 2) A straight literal string can then either be merged with
//    the leadin of the next expression or the trailing of
//    the prior expression, or it stands alone.
//
strCompoundElement [ ListBuffer<F3Expression> strexp ]
    
    : stringLiteral [ strexp ]          
    | qlsl          [ strexp ]
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Flag we are in the error state
    //
    $stringExpression::inError = true;  
}

// ---------------
// String literals
// We may have multiple string literals following each
// other, which we auto concatentate here at compile time
//
//
stringLiteral [ ListBuffer<F3Expression> strexp ]


@init
{
    // Record position of invalid expression used in compile time
    // string compounding.
    //
    int ePos;
    
    // Used to accumulate multiple string literals
    //
    StringBuffer sbLit = new StringBuffer();
    
    // The string litereal we will created
    //
    F3Expression sVal = null;

}
    : s1=STRING_LITERAL 
    
        {
            // Accumulate the literal
            //
            sbLit.append($s1.text);
        }
    
        (
            (STRING_LITERAL)=> s2=STRING_LITERAL
            
            {
                // Accumulate the literal
                //
                sbLit.append($s2.text);
            }
        )*
        
        {

            // Here, one of the following conditions prevails
            //
            //  i)  We have as yet encountered no components of the compound
            //      string and so we can assume for the moment that the literal
            //      string elements we have accumulated so far will remain as
            //      a simple string literal, and so just add the literal we
            //      make as one element.
            // ii)  There has already been some sort of compound expression
            //      in which case there will be more than 0 elements currently in
            //      the compound element list. The list will always be left with
            //      the trailing part of the expression string as the last element
            //      of the list as it is built of "leading{\%format expr}trailing".
            //      So, we can remove the last entry, append this newly accumulated
            //      string literal to it, and move on.
            //
            if  ( $stringExpression::inError || strexp.size() == 0)
            {
            
                // Now we create the actual string literal
                //
                sVal = F.at(pos($s1)).Literal(TypeTags.CLASS, sbLit.toString());
            
                // Add to list
                //
                strexp.append(sVal);

                // Tree span
                //
                endPos(sVal);
            
            }
            else
            {
                // Already had the first expression, replace the traling part of the
                // last expression with a concatenation of it and this newly found
                // string.
                //
                F3Literal trailer = (F3Literal)(strexp.elems.get(strexp.size()-1));
                
                // Now, append the string we have to the prior trailing part
                // 
                sbLit.insert(0, (String)(trailer.getValue()));
                
                // Replace the original value
                //
                trailer.value = sbLit.toString();
                
            }

        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Flag we are in the error state
    //
    $stringExpression::inError = true;
    
}
    
// --------------------
// String lit component
// String literals with embedded formats/expressions
//
qlsl [ ListBuffer<F3Expression> strexp]

    :   ql=QUOTE_LBRACE_STRING_LITERAL  
    
            {
                if  ($stringExpression::inError) {
                
                    // Add the leadin string
                    //
                    F3Literal leader = F.at(pos($ql)).Literal
                                            (   TypeTags.CLASS,
                                                $ql.text
                                            );
                    endPos(leader);
    
                    // Add it in to the list
                    //
                    strexp.append(leader);
                            
                } else {
                    // Add in the discovered literal value
                    //
                    // Here, one of the following conditions apply:
                    //
                    //   i) There are currently no entries in the buffer. The size of strexp
                    //      will be 0 in that case and we can process the expression without 
                    //      regard to prior values.
                    //  ii) There was one or leading string literals (non expressions),
                    //      in which case the list buffer size will be 1, representing
                    //      the accumulated string literal. In that case we must append
                    //      the leadin string ($ql above) to the existing string and make
                    //      it the leadin for this expression.
                    // iii) There were prior expressions in the list, in which case, as per
                    //      ii) we must merge the last literal in the buffer with ($ql) from
                    //      above and make it the leadin string for this expression.
                    //      NB: THis can only arise from "{expr}" ("STRING")* "{expr}"
                    //
                    switch  (strexp.size())
                    {
                        case 0:
                
                            // Add the leadin string
                            //
                            F3Literal leader = F.at(pos($ql)).Literal
                                                (   TypeTags.CLASS,
                                                    $ql.text
                                                );
                            endPos(leader);
    
                            // Add it in to the list
                            //
                            strexp.append(leader);
                            
                            break;  
    
                    default:
                        
                            // Already had a single first literal, or a trailer for an 
                            // expression - make it belong to this leader.
                            //
                            leader = (F3Literal)(strexp.elems.get(strexp.size()-1));
                    
                            // Now, append the string we have to the prior trailing part
                            // and replace the original value
                            //
                            leader.value = (String)(leader.getValue()) + $ql.text;
                            break;
                    }
                }
            }
            
        // Optional string format
        //
        stringFormat    [strexp]
        
        // An expression to evaluate at runtime
        // 
        e2=expression                   { strexp.append($e2.value); }
      
        // Any number of inner elements
        //
        ( stringExpressionInner [strexp]  )*   
      
        // The last component of the {} enclosing string literal
        //
        qr=RBRACE_QUOTE_STRING_LITERAL
      
            {
                // Add in the discovered literal
                //
                F3Literal trailer = F.at(pos($qr)).Literal
                                            (   TypeTags.CLASS,
                                                $qr.text
                                            );
                endPos(trailer);
                
                // Add to the list
                //
                strexp.append(trailer); 
            }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Flag we are in the error state
    //
    $stringExpression::inError = true;  
}

// ----------------------
// String element with optional format expression
//
stringExpressionInner [ ListBuffer<F3Expression> strexp]

    : rlsl=RBRACE_LBRACE_STRING_LITERAL 
    
        {
            // Construct a new literal for the leading literal
            //
            F3Expression rb = F.at(pos($rlsl)).Literal(TypeTags.CLASS, $rlsl.text);
            
            // Record the span
            //
            endPos(rb);
            
            // Add the literal to the list
            //
            strexp.append(rb);
            
        }
        
        // Deal with the string format
        //
        stringFormat[strexp] 
        
        // Expression to evaluate at runtime
        //
        expression
        
        {
            strexp.append($expression.value);
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Flag we are in the error state
    //
    $stringExpression::inError = true;  
}

// --------------------
// Format specification
// Optional format specifier in standard Java form
//
stringFormat [ ListBuffer<F3Expression> strexp]

@init
{
    // The value to add in to the mix
    //
    F3Expression value;
    
    // Work out current position in the input stream
    //
    int rPos = pos();
    
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
}
    : fs=FORMAT_STRING_LITERAL
    
        {
            value = F.at(rPos).Literal(TypeTags.CLASS, $fs.text);
            endPos(value);
            strexp.append(value);
        }
        
    | // no format
        {
            value = F.at(rPos).Literal(TypeTags.CLASS, "");
            endPos(value, rPos);    // Needs to be shown as a non-existant string to the IDE
            strexp.append(value);
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Flag we are in the error state
    //
    $stringExpression::inError = true;  
}
    
// ---------------------------
// Sequence
// Which is a [] enclosed expression list
//
bracketExpression

    returns [F3Expression value]   // Expression tree for stringExpressions

@init
{
    // Buffer in which to accumulate all string elements
    //
    ListBuffer<F3Expression> seqexp = new ListBuffer<F3Expression>();
    
    // Work out current position in the input stream
    //
    int rPos = pos();
    
    // Optional step expression
    //
    F3Expression   stepEx = null;
    
    // Optional LT qualifier
    //
    boolean     haveLT  = false;
    
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
}

    : LBRACKET   
    
        (   e1=expression
                {
                    seqexp.append($e1.value);
                    errNodes.append($e1.value);
                }
                (
                        
                          (
                            
                            (
                                  COMMA
                                | {
                                        // Object literals need not be delimited, but everything
                                        // else must be. Object literals end in '}' of course
                                        //
                                        if (input.LA(-1) != RBRACE)
                                        {
                                            log.error(semiPos(), MsgSym.MESSAGE_F3_MANDATORY_COMMA);
                                        }
                                  }
                            )
                            e2=expression
                                {
                                    seqexp.append($e2.value);
                                    errNodes.append($e2.value);
                                }
                          )*
                          COMMA?

                        
                        {
                            // Explicit sequence detected
                            //
                            $value = F.at(rPos).ExplicitSequence(seqexp.toList());
                        }
                        
                    | DOTDOT
                        (LT { haveLT = true; })? 
                        
                        dd=expression   { errNodes.append($dd.value); }
                        
                        ( 
                            STEP st=expression 
                                    { 
                                        stepEx = $st.value; 
                                        errNodes.append($st.value); 
                                    } 
                        )?
                        
                        {
                            $value = F.at(rPos).RangeSequence($e1.value, $dd.value, stepEx, haveLT);
                        }
                )
                
             |  // Empty sequence 
                {
                     $value = F.at(rPos).EmptySequence();
                }
        )
      RBRACKET
      {
        endPos($value);
      }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);

    // Create an ERRONEOUS node
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
    endPos($value); 
}

// ----------------
// Expression list.
// Comma separated list of expressions.
//
expressionList

    returns [ListBuffer<F3Expression> args = new ListBuffer<F3Expression>()]  // List of expressions we pcik up
    
@init
{
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    
    // Work out current position in the input stream
    //
    int rPos = pos();
}
    : e1=expression
        
        {
            args.append     ($e1.value);
            errNodes.append ($e1.value);
        }
        
        (
            (COMMA | { log.error(semiPos(), MsgSym.MESSAGE_F3_MANDATORY_COMMA);} )  
            e2=expression
            
            {
                args.append     ($e2.value);
                errNodes.append ($e2.value);
            }
        
        )*
        COMMA?
    |
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Create an ERRONEOUS node
    //
    F3Erroneous errNode = F.at(rPos).Erroneous(args.elems);
    endPos(errNode);
    args = new ListBuffer<F3Expression>();
    args.append(errNode);
    
}

// ------------------------
// Optional expression list
// For the moment this is only used by New....
//
expressionListOpt
    
    returns [ListBuffer<F3Expression> args = new ListBuffer<F3Expression>()]  // List of expressions we pcik up

    : (LPAREN)=>LPAREN expressionList
        {
            $args = $expressionList.args;
        }
       RPAREN

    |   // Was not present
    ;

// -----
// Types
//
type

    returns [F3Type rtype]
    
@init
{
    // Work out current position in the input stream
    //
    int rPos = pos();

    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
}
    : (typeName  { errNodes.append($typeName.value); }
    
        cardinality
    
        {
        
            if  ($typeName.value  instanceof F3Erroneous) {
            
                // The type did not parse correctly, so we create it as
                // an erroneous element
                //
                $rtype = F.at(rPos).ErroneousType(errNodes.elems);
                
            } else {
            
                $rtype = F.at(rPos).TypeClass($typeName.value, $cardinality.ary);
            }
            endPos($rtype);
        }
        
    | typeFunction  { $rtype = $typeFunction.rtype; } 
    | typePrefixed  { $rtype = $typePrefixed.rtype; }) 
    
//    | typeStar      { $rtype = $typeStar.rtype;     }
    ;

// Catch an error when looking for a type. The only error we can
// have is that there was nothing that predict any of the alts, 
// so we create an error node for placing in the AST
//
catch [RecognitionException re] {
  
    // Now create an AST node that represents a missing type, The required entry
    // is of type Name so we use an identifier name that cannot exist in
    // F3, so that IDEs can detect it.
    //
    // Note that if this was part of a type refernce: ':' tttt, then we want to
    // report the error with reference to the ':' as this is easier for the IDE
    // to handle.
    //  
    if  (input.LA(-1) == COLON) {
    
        rPos = pos(input.LT(-1));   // Get the start point of the previous token.
    }
    
    $rtype = F.at(rPos).ErroneousType(errNodes.elems);
    endPos($rtype);
    
    // Now report the error as the user needs to know about it, but with 
    // refernce to the error type
    //
    reportError(re, $rtype);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
 }

typeAlias
    returns [F3Type rtype]

@init
{
    ListBuffer<F3Expression> exprbuff = ListBuffer.<F3Expression>lb();
}
: 
TYPE id=IDENTIFIER (OF gas=genericParams[false, false] {exprbuff.appendList(gas);})? EQ t=type
        {
            Name name = Name.fromString(names, $id.text);
            $rtype = F.at($id.pos).TypeAlias(name, exprbuff.toList(), $t.rtype);
        }
;

typeFunction

    returns [F3Type rtype]

@init
{
    // Work out current position in the input stream
    //
    int rPos = pos();

    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    // Accumulate any generic arguments
    //
    ListBuffer<F3Expression> exprbuff = ListBuffer.<F3Expression>lb();
    com.sun.tools.mjavac.util.List<F3Type> argsList = null;
    ListBuffer<F3Type> typeArgBuf = ListBuffer.<F3Type>lb();

}

    : 

    FUNCTION 

        ((OF | FORALL) gas1=genericParams[false, false] { 
                exprbuff.appendList($gas1.value);
           })?
    (
      (FROM)=>(FROM ((LPAREN)=>(LPAREN (t=type {typeArgBuf.append($t.rtype);} (COMMA t0=type {typeArgBuf.append($t0.rtype);})* )? RPAREN) | t1=type {typeArgBuf.append($t1.rtype);}) TO ret=type) { argsList = typeArgBuf.toList(); }
    |
        (LPAREN 
            typeArgList 
                { 
		    argsList = $typeArgList.ptypes.toList();
                    for (F3Tree tt : $typeArgList.ptypes) { 
                        errNodes.append(tt); 
                    } 
                }
        RPAREN 
        
        
            ret=typeReference   { errNodes.append($ret.rtype); }
    //|
        //ARROW ret=type { errNodes.append($ret.rtype); }
    //( (a=type ARROW ret=type) { })+
    )
)            
            cardinality //TODO: this introduces an ambiguity: return cardinality vs type cardinality

        {
            $rtype = F.at(rPos).TypeFunctional(argsList, exprbuff.toList(), $ret.rtype, $cardinality.ary);
            endPos($rtype);
        }

    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    $rtype = F.at(rPos).ErroneousType(errNodes.elems);
    endPos($rtype);
}

typePrefixed

    returns [F3Type rtype]

@init
{
    // Work out current position in the input stream
    //
    int rPos = pos();
    
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();

}
    : NATIVEARRAY OF type
    
        {
            $rtype = F.at(rPos).TypeArray($type.rtype);
            endPos($rtype);
        }
    ;
 // Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
}

typeStar

    returns [F3Type rtype]

@init
{
    // Work out current position in the input stream
    //
    int rPos = pos();
    
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();

}
    : STAR cardinality
    
        {
            $rtype = F.at(rPos).TypeAny($cardinality.ary);
            endPos($rtype);
        }
    ;
 // Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
}

// ----------------------------
// A list of types as arguments
//
typeArgList
    
 returns [ListBuffer<F3Type> ptypes = ListBuffer.<F3Type>lb(); ]
 
@init
{
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
}
    : t1=typeArg
    
        {
            ptypes.append($t1.rtype);
        }
         
        (
            COMMA   
            t2=typeArg
            
            {
                ptypes.append($t2.rtype);
            }
        
        )*
        COMMA?
    |
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
}

// -------------------------
// Individual typed argument
//
typeArg 

    returns [F3Type rtype]

@init
{
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
}
    : (
        (
            name    // TODO: Check this, it is currently ignored for AST and does not
                    //       look quite right.
        )? 
            COLON
      )?
      
      type
    
        {
            $rtype = $type.rtype;
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
}

 // --------------
 // Type reference
 // Used to build parameter lists for functions etc
typeReference

    returns [F3Type rtype]
    
@init
{
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    
    // Work out current position in the input stream
    //
    int rPos = pos();
}
    : COLON type
              
        {
            $rtype = $type.rtype;
        }
        
    | // Untyped element, the AST needs to reflect that
    
        { 
            $rtype = F.at(rPos).TypeUnknown(); 
            endPos($rtype);
        }

    ;
 // Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // To avoid the complications of what to create class wise if
    // we get an error here, we create a dummy unknown type. Because
    // we log the error, we won't perform codegen, but the IDE will
    // have something to work with.
    //
    $rtype = F.at(rPos).TypeUnknown();
    endPos($rtype);
    
    // Now, let's report the error as the user needs to know about it, but with
    // reference to our new node.
    //
    reportError(re, $rtype);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
}

// -------------------------
// Array indicator for types
//
cardinality

    returns [TypeTree.Cardinality ary]

@init
{
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
}
    : (LBRACKET)=>LBRACKET RBRACKET
    
        {
            $ary = TypeTree.Cardinality.ANY;
        }
    |
    (STAR STAR STAR)=>(STAR STAR STAR) // hack
        {
            $ary = TypeTree.Cardinality.SINGLETON;
        }
    |
    (STAR STAR)=>(STAR STAR) // hack
        {
            $ary = TypeTree.Cardinality.SINGLETON;
        }
    |
    (STAR)=>(STAR) // hack
        {
            $ary = TypeTree.Cardinality.SINGLETON;
        }
    |
        {
            $ary = TypeTree.Cardinality.SINGLETON;
        }

    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
}

// ----------
// Named type
// Possibly a generic
//
typeName

    returns [F3Expression value]

@init
{
    // Accumulate any generic arguments
    //
    ListBuffer<F3Expression> exprbuff = ListBuffer.<F3Expression>lb();
    
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    
    // Work out current position in the input stream
    //
    int rPos = pos();
    F3Expression name = null;
}

: (UPPER_THIS | qualname      { errNodes.append($qualname.value); name = $qualname.value;} )
        (
              (OF)=>OF gas=genericArguments  { if ($gas.value != null) exprbuff.appendList($gas.value); }
              {
                // AST for generic
                //
                //F3Erroneous err = F.at(pos($OF)).Erroneous();
                //endPos(err);
                //log.error(err, MsgSym.MESSAGE_F3_GENERICS_UNSUPPORTED);
                
                // Ensure that the IDE plugin does not fall over
                //
		  if (name != null) {
		      $value = F.at(rPos).Ident(name, exprbuff.toList());
		  } else 
{		      $value = F.at(rPos).TypeThis(TypeTree.Cardinality.SINGLETON, $gas.value);
		  }
              }
              
            |   // Non generic
                {
		    if (name != null) {
                        $value = name;
		    } else {
			$value = F.at(rPos).TypeThis(TypeTree.Cardinality.SINGLETON, com.sun.tools.mjavac.util.List.<F3Expression>nil());
		    }
                }
        )
    | LPAREN typeparens RPAREN  // Allows cardinality coherence, using nested paren parsing trick
    
        { $value = $typeparens.value; }
    ;
    

    
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    $value = F.at(rPos).Erroneous(errNodes.elems);
    endPos($value);
    
}

genericArguments
   returns [com.sun.tools.mjavac.util.List<F3Expression> value]
   :
   (LPAREN)=> (LPAREN (gas=genericArguments0) RPAREN)
   {
       $value = $gas.value;
   }
   |
   ga=genericArgument 
   {
       ListBuffer<F3Expression> exprbuff = ListBuffer.<F3Expression>lb();
       exprbuff.append($ga.value);
       $value = exprbuff.toList();
   }
;

genericArguments0
   returns [com.sun.tools.mjavac.util.List<F3Expression> value]
@init {
   ListBuffer<F3Expression> exprbuff = ListBuffer.<F3Expression>lb();
}
   :
   (ga1=genericArgument 
   {
	exprbuff.append($ga1.value);
   } 
   (
	COMMA ga2=genericArgument 
	{
            exprbuff.append($ga2.value);
        }
   )*)?
   {$value = exprbuff.toList();}
;


genericParams[boolean contravar, boolean covar]
   returns [com.sun.tools.mjavac.util.List<F3Expression> value]
   :
   (LPAREN)=> (LPAREN (gas=genericParams0[contravar, covar]) RPAREN)
   {
       $value = $gas.value;
   }
   |
   ga=genericParam[contravar, covar]
   {
       ListBuffer<F3Expression> exprbuff = ListBuffer.<F3Expression>lb();
       exprbuff.append($ga.value);
       $value = exprbuff.toList();
   }
;

genericParams0[boolean contravar, boolean covar]
   returns [com.sun.tools.mjavac.util.List<F3Expression> value]
@init {
   ListBuffer<F3Expression> exprbuff = ListBuffer.<F3Expression>lb();
}
   :
   ga1=genericParam[contravar, covar]
   {
	exprbuff.append($ga1.value);
   } 
   (
	COMMA ga2=genericParam[contravar, covar]
	{
            exprbuff.append($ga2.value);
        }
   )* 
   {$value = exprbuff.toList();}
;


// When a programmer accidentally c=ecloses the type in two or more
// sets of prens, we do't want to change the type, but just treat extra
// parens as superfluous precedence, hence this rule.
//
typeparens

    returns [F3Expression value]
    
    : (LPAREN)=>LPAREN t=typeparens RPAREN
    
        { $value = $t.value; }
        
    | type
    
        { $value = $type.rtype; }
    ;

genericParam[boolean contravar, boolean covar]

    returns [F3Expression value]

@init 
{
    BoundKind       bk      = (!contravar && !covar) ? BoundKind.UNBOUND : (contravar)? BoundKind.SUPER : BoundKind.EXTENDS;
    F3Expression   texpr   = null; 
}

    : (t=identifier  { $value = $t.value; })  (COLON)=>(COLON bound=typeName { $value = F.at($bound.value.pos).TypeVar($value, TypeTree.Cardinality.SINGLETON, bk, $bound.value);})?

      | 
       (CLASS n=identifier OF gas=genericParams[false, false] { 
        $value = F.at($n.value.pos).TypeCons($n.value, TypeTree.Cardinality.SINGLETON, $gas.value);
      })
/*    
    | QUES 
        (  
            ( 
                  EXTENDS       { bk = BoundKind.EXTENDS;   }
                | SUPER         { bk = BoundKind.SUPER;     }
            ) 
            typeName            { texpr = $typeName.value; }
        )?
        
        {
            // TODO: NYI - Remove or implement?
        }
*/
    ;


genericArgument

    returns [F3Expression value]

@init 
{
    BoundKind       bk      = BoundKind.EXTENDS;
    F3Expression   texpr   = null; 
}

      : t=type  { $value = $t.rtype; }
        //  (COLON)=>(COLON bound=typeName { $value = F.at($bound.value.pos).TypeVar($value, TypeTree.Cardinality.SINGLETON, bk, $bound.value);})?
      |
      q=QUES {$value = F.at($q.pos).TypeExists();}
     
/*    
    | QUES 
        (  
            ( 
                  EXTENDS       { bk = BoundKind.EXTENDS;   }
                | SUPER         { bk = BoundKind.SUPER;     }
            ) 
            typeName            { texpr = $typeName.value; }
        )?
        
        {
            // TODO: NYI - Remove or implement?
        }
*/
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
}

// --------
// Literals.
// Incorporates all literals except STRING_LITERAL which is dealt with
// in the stringExpression rule
//
literal

    returns [F3Expression value]
    
@init
{
    // Work out current position in the input stream
    //
    int rPos = pos();
}
    : 
        (
             DECIMAL_LITERAL
            
                {
                    $value = F.at(rPos).LiteralInteger($DECIMAL_LITERAL.text, 10);
                }
                
            | OCTAL_LITERAL
            
                {
                    $value = F.at(rPos).LiteralInteger($OCTAL_LITERAL.text, 8);
                }
            
            | HEX_LITERAL
            
                {
                    $value = F.at(rPos).LiteralInteger($HEX_LITERAL.text, 16);
                }

            | timeValue

                {
                    $value = $timeValue.valNode;
                }

            | lengthValue

                {
                    $value = $lengthValue.valNode;
                }

            | angleValue

                {
                    $value = $angleValue.valNode;
                }

            | colorValue

                {
                    $value = $colorValue.valNode;
                }
                
            | FLOATING_POINT_LITERAL
            
                {
                    $value = F.at(rPos).Literal(TypeTags.DOUBLE, Double.valueOf($FLOATING_POINT_LITERAL.text));
                }
                
            | (TRUE | YES)
            
                {
                    $value = F.at(rPos).Literal(TypeTags.BOOLEAN, 1);
                }
                
            | (FALSE | NO)
            
                {
                    $value = F.at(rPos).Literal(TypeTags.BOOLEAN, 0);
                }
                
            | NULL
            
                {
                    $value = F.at(rPos).Literal(TypeTags.BOT, null);
                }
        )
        
        {
            // Tree span
            //
            endPos($value);
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
}

// -------------------------    
// Qualified (possibly) name
//
qualname

    returns [F3Expression value, boolean inError]
    
@init
{
    // Used to accumulate a list of anything that we manage to build up in the parse
    // in case of error.
    //
    ListBuffer<F3Tree> errNodes = new ListBuffer<F3Tree>();
    
    // Start of this rule
    //
    int rPos = pos();
    
    // Indicates that despite parsing correctly, we discovered an error here
    // and so this should be erroneous.
    //
    $inError = false;
    
    $value = null;
}
    : (
            n1=name
            {
                if  ($n1.inError || $n1.value == null) {
                
                    // The rule caused an identifier to be made up
                    //
                    $inError = true;
                }
                
                $value = F.at($n1.pos).Ident($n1.value);
                endPos($value);
            
                // Accumulate in case of error
                //
                errNodes.append($value);
            }
            (
                
                (DOT)=>DOT

                (
                        (nameAll)=>n2=nameAll
                        {
                            
                            if  ($n2.inError || $n2.value == null) {
                
                                // The rule caused an identifier to be made up
                                //
                                //$inError = true;
                            }
                            
                            $value = F.at(pos($DOT)).Select($value, $n2.value, false);
                            endPos($value); 
                            
                            // Build up new node in case of error
                            //
                            F3Expression part = F.at($n2.pos).Ident($n2.value);
                            errNodes.append(part);
                            endPos(part);
                        }

                    |   {
                            $value = F.at(pos($DOT)).Select($value, Name.fromString(names, "<missing>"), false);
                            endPos($value);
                            log.error(semiPos(), MsgSym.MESSAGE_F3_INCOMPLETE_QUAL);
                        }
                )
            )*  
        )
        
        // If the rule actually discovered some error, then we do
        // not return the $value as a good qualified name, but as an erroneous node
        //
        {
            if  ($inError)  {
            
                // Create the error node
                //
                $value = F.at(rPos).Erroneous(errNodes.elems);
                endPos($value);
            }
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {

    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);
    
    // Create the error node
    //
    $value = F.at(rPos).Erroneous(errNodes.elems);
    endPos($value);
    
    $inError = true;
    
}

// ----------
// Time value
// Invoked to pick up a specialized time token and create a special node
// that indicates it was missing, if the parser created it etc.
//
timeValue

    returns [F3TimeLiteral valNode]

@init
{
    // Work out current position in the input stream
    //
    int rPos = pos();
}

    : TIME_LITERAL

        {
            // Check to see if error recovery made up this value for us
            //
            if  ($TIME_LITERAL instanceof MissingCommonToken) {

                $valNode = F.at(pos($TIME_LITERAL)).ErroneousTimeLiteral();

            } else {

                // Create a real node
                //
                $valNode = F.at(pos($TIME_LITERAL)).TimeLiteral($TIME_LITERAL.text);
            }
            endPos($valNode);
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {

    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);

    // Create the error node
    //
    $valNode = F.at(rPos).ErroneousTimeLiteral();
    endPos($valNode);

}

// ----------
// Length value
// Invoked to pick up a specialized length token and create a special node
// that indicates it was missing, if the parser created it etc.
//
lengthValue

    returns [F3LengthLiteral valNode]

@init
{
    // Work out current position in the input stream
    //
    int rPos = pos();
}

    : LENGTH_LITERAL

        {
            // Check to see if error recovery made up this value for us
            //
            if  ($LENGTH_LITERAL instanceof MissingCommonToken) {

                $valNode = F.at(pos($LENGTH_LITERAL)).ErroneousLengthLiteral();

            } else {

                // Create a real node
                //
                $valNode = F.at(pos($LENGTH_LITERAL)).LengthLiteral($LENGTH_LITERAL.text);
            }
            endPos($valNode);
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {

    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);

    // Create the error node
    //
    $valNode = F.at(rPos).ErroneousLengthLiteral();
    endPos($valNode);

}

// ----------
// Angle value
// Invoked to pick up a specialized angle token and create a special node
// that indicates it was missing, if the parser created it etc.
//
angleValue

    returns [F3AngleLiteral valNode]

@init
{
    // Work out current position in the input stream
    //
    int rPos = pos();
}

    : ANGLE_LITERAL

        {
            // Check to see if error recovery made up this value for us
            //
            if  ($ANGLE_LITERAL instanceof MissingCommonToken) {

                $valNode = F.at(pos($ANGLE_LITERAL)).ErroneousAngleLiteral();

            } else {

                // Create a real node
                //
                $valNode = F.at(pos($ANGLE_LITERAL)).AngleLiteral($ANGLE_LITERAL.text);
            }
            endPos($valNode);
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {

    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);

    // Create the error node
    //
    $valNode = F.at(rPos).ErroneousAngleLiteral();
    endPos($valNode);

}

// ----------
// Color value
// Invoked to pick up a specialized color token and create a special node
// that indicates it was missing, if the parser created it etc.
//
colorValue

    returns [F3ColorLiteral valNode]

@init
{
    // Work out current position in the input stream
    //
    int rPos = pos();
}

    : COLOR_LITERAL

        {
            // Check to see if error recovery made up this value for us
            //
            if  ($COLOR_LITERAL instanceof MissingCommonToken) {

                $valNode = F.at(pos($COLOR_LITERAL)).ErroneousColorLiteral();

            } else {

                // Create a real node
                //
                $valNode = F.at(pos($COLOR_LITERAL)).ColorLiteral($COLOR_LITERAL.text);
            }
            endPos($valNode);
        }
    ;
// Catch an error. We create an erroneous node for anything that was at the start
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {

    // First, let's report the error as the user needs to know about it
    //
    reportError(re);

    // Now we perform standard ANTLR recovery here
    //
    recover(input, re);

    // Create the error node
    //
    $valNode = F.at(rPos).ErroneousColorLiteral();
    endPos($valNode);

}

// -----------------------
// ID
// Basic identifier parse
//
identifier

    returns [F3Ident value, boolean inError]

@init
{
    // Assume the input will be there
    //
    $inError = false;
        
    // Work out current position in the input stream
    //
    int rPos = pos();
}
    : IDENTIFIER
        {
            // The recovery mechanisms will auto generate the IDENTIFIER
            // token, in the case that it can predict that it was just a single
            // token that the programmer forgot to use. Hence we must
            // pick up on that and generate a different node for a Missing
            // identifier.
            //
            if ($IDENTIFIER instanceof MissingCommonToken) {
            
                $value = F.at(rPos).ErroneousIdent();
                endPos($value, pos());
                $inError = true;
                
            } else {
            
                Name name = Name.fromString(names, $IDENTIFIER.text);
                $value = F.at(rPos).Ident(name);
                endPos($value, rPos + name.length());
            }
        }
    ;

// -----------------------
// ID
// Basic identifier parse, but when Any keyword, including reserved
// words, is allowed.
//
identifierAll

    returns [F3Ident value, boolean inError]

@init
{
    // Assume the input will be there
    //
    $inError = false;   

    // Work out current position in the input stream
    //
    int rPos = pos();
}
    : IDENTIFIER
        {
            // The recovery mechanisms will auto generate the IDENTIFIER
            // token, in the case that it can predict that it was just a single
            // token that the programmer forgot to use. Hence we must
            // pick up on that and generate a different node for a Missing
            // identifier.
            //
            if ($IDENTIFIER instanceof MissingCommonToken) {
            
                $value = F.at(rPos).ErroneousIdent();
                endPos($value, pos());
                $inError = true;
                
            } else {
            
                Name name = Name.fromString(names, $IDENTIFIER.text);
                $value = F.at(rPos).Ident(name);
                endPos($value, rPos + name.length());
            }
        }
        
    | aw=allWords
        {
            
                Name name = Name.fromString(names, $aw.text);
                $value = F.at(rPos).Ident(name);
                endPos($value, rPos + name.length());
        }
    ;
 
// ------------------------
// ID
// Parse and identifier token that isn't necessarilly an Identifier,
// it could just be a tag or function name etc.
//
name 

    returns [Name value, int pos, boolean inError]
@init
{
    // Assume the input will be there
    //
    $inError = false;   

    // Work out current position in the input stream
    //
    int rPos = pos();
}
    : IDENTIFIER
    
        { 
            $value = Name.fromString(names, $IDENTIFIER.text); 
            $pos = rPos; 
            
            if  ($IDENTIFIER instanceof MissingCommonToken) {
            
                $inError = true;        // Recognizer manufactured this for us
            
            } else {
            
                $inError = false;       // It was genuinely there
            }
        }
    | aw=keyword
        { 
            $value = Name.fromString(names, $aw.text); 
            $pos = rPos; 
        }
    ;
    
// ------------------------
// ID
// Parse and identifier token that isn't necessarilly an Identifier,
// it could just be a tag or function name etc.
//
nameAll 

    returns [Name value, int pos, boolean inError]
    
@init
{
    // Assume the input will be there
    //
    $inError = false;   

    // Work out current position in the input stream
    //
    int rPos = pos();
}
    : IDENTIFIER
    
        { 
            $value = Name.fromString(names, $IDENTIFIER.text); 
            $pos = rPos; 
            
            if  ($IDENTIFIER instanceof MissingCommonToken) {
            
                $inError = true;        // Recognizer manufactured this for us
            
            } else {
            
                $inError = false;       // It was genuinely there
            }
        }
    | aw=allWords
        { 
            $value = Name.fromString(names, $aw.text); 
            $pos = rPos; 
            $inError = false;
        }
    ;
    
// ----------
// All tokens
//
// The set of keywords, both reserved and non-reserved words, which
// can sometimes be used as Indentifiers, such as elements of
// import statements and second and subsequent elements of compound references
//
allWords
    : keyword
    | reservedWord
    ;
    
// ---------------------
// Non-reserved keywords
//
// Some tokens are returned by the lexer as keywords for the grammar
// but are not reserved words in the language. These can be used as
// identifiers and are basically the set of keywords that cannot
// possibly start a statement/expression, such as 'to' but not those
// that are not sensible to allow as identifiers, such as 'true'.
//
keyword
    : FIRST     | IN    | INIT      | INTO
    | INVERSE   | LAST  | ON        | POSTINIT      
    | REPLACE   | STEP  | TRIGGER   | TWEEN
    | WHERE     | WITH  | INVALIDATE
    ;

// --------------
// Reserved words
//
// Tokens returned by the lexer that cannot be used as Identifiers
// but can be valid in some circumstances, such as components of
// an import statement, or as second and subsequent elements of
// compounds such as x.public.for.function()
//
reservedWord
    : ABSTRACT      | AFTER     | AND           | AS
    | ASSERT        | AT        | ATTRIBUTE     | BEFORE
    | BIND          | BOUND     | BREAK         | CASCADE
    | CATCH         | CLASS     | CONTINUE      | DEF | ENUM | OF | FORALL
    | DEFAULT       | DELETE    | ELSE          | EXCLUSIVE
    | EXTENDS       | FALSE     | FINALLY       | FOR
    | FROM          | FUNCTION  | IF            | IMPORT
    | INDEXOF       | INSERT    | INSTANCEOF    | LAZY
    | MIXIN         | MOD       | NATIVEARRAY   | NEW | INTERFACE
    | NOT           | NULL      | OR            | OVERRIDE
    | PACKAGE       | PRIVATE   | PROTECTED     | PUBLIC
    | PUBLIC_INIT   | PUBLIC_READ | RETURN      | REVERSE
    | SIZEOF        | STATIC    | SUPER         | THEN
    | THIS          | THROW     | TRUE          | TRY
    | TYPEOF        | VAR       | WHILE
    ;


// -----------------------
// Process a SEMI colon that is always required, regardless of
// where the contruct is in the script. There are not too many
// of these.
//
requiredSemi 
    : { input.LA(1) != SEMI}?=>
    
      // If there was no semi colon here, then we need to issue an error
      // though we don't worry about it syntactically.
      //
      {
          log.error(semiPos(), MsgSym.MESSAGE_F3_SEMI_REQUIRED);
      }
    
    | (SEMI)=>SEMI      // This is what we want 
    ;

// -------------------------
// Decides whether a SEMI is required at this point in the parse (and issues
// an error if it is and is not present), or is optional (in which case it eats it) or
// we have just consumed one, which means we can not worry about it as the
// previous rule obviously decided that it wasn't optional and consumed it.
// This rule could result in doubly reporting the absent semi colon if there
// is a construct that consumes one, but does not find one, then a higher
// rule calls this rule, which also decides one is necessary as it did not see one.
// However, the grammar is carefully constructed such that this does not happen
//
possiblyOptSemi
    :   
            {
                // Call super class function to decide whether to look for
                // the SEMI or not and whether to log an error if one is 
                // missing.
                //
                checkForSemi();
            }
    ;

